CONFIGURATION

all processes read configuration information from a configuration file whose name is specified on the command line.  for simplicity, all processes read the same configuration file, and each kind of process ignores irrelevant information.  give configuration files meaningful names!  this will help you keep track of them and help graders understand them.

the configuration file contains enough information to specify a test case; thus, a user can run different test cases simply by supplying different configuration files.  this includes specification of the client workload and a failure scenario.

client workload may be a list of specific requests or pseudorandom.  the former is a semicolon-separated list of invocations of the 4 operations listed above; the exact syntax is shown in the example configuration file below.  a pseudorandom workload is specified using the syntax pseudorandom(seed, n), which denotes a sequence containing n pseudorandom requests, with the specified seed for the pseudorandom number generator (for reproducibility).  details of pseudorandom request generation are not standardized: any method that generates a diverse sequence of requests is acceptable.

a failure scenario is a semicolon-separated set (not a sequence, i.e., the order doesn't matter) of trigger,failure pairs for a specified replica.  we do not consider failures of clients or Olympus.  each trigger corresponds to receiving a message of a specified type and has the form message_type(args), as described in detail below. when the event specified by the trigger occurs, the specified failure occurs.  your system should contain fault-injection code that simulates these failures.  try to encapsulate fault-injection code in separate functions as much as possible, to minimize its impact on the readability of the code for the protocol itself.

required failure triggers are listed below, where c >= 0 and m >= 0, i.e., clients c and received messages m are numbered starting from 0.  this message numbering is done independently by each replica (using an auxiliary data structure) for each message type from each client.  the numbering is continuous (not reset) across configurations.

-----
failure triggers for phases 2 and 3:   [2017-09-12: postponed some triggers to phase 3, and added two triggers related to checkpoints.]

client_request(c, m): receipt of m'th request message directly from client c.  requests received directly from client c are numbered separately from requests of client c received via forwarding by other replicas.
 
forwarded_request(c, m): receipt of m'th forwarded request message containing a request from client c.

shuttle(c, m): receipt of m'th shuttle message for a request by client c.

result_shuttle(c, m): receipt of m'th result-shuttle message for a request by client c.

-----
failure triggers for phase 3 only:

wedge_request(m): receipt of m'th wedge-request message. [phase 3 only]

new_configuration(m): receipt of m'th new_configuration message from Olympus.  it doesn't matter whether your implementation actually sends a new_configuration message for the initial configuration; either way, m=0 corresponds to the first configuration change after the initial configuration.

checkpoint(m): receipt of m'th checkpoint message [phase 3 only] [2017-09-12: added this item.]

completed_checkpoint(m): receipt of m'th completed checkpoint message [phase 3 only] [2017-09-12: added this item.]

----
required failures for phases 2 and 3: [2017-09-12: postponed some failures to phase 3, added drop_result_stmt, and removed omit_send() (use drop() on the receiver-side instead).]

change_operation(): in the next outgoing shuttle message, this replica uses get('x') as the operation in its order statement and result statement, regardless of what the operation should be.

change_result(): in the next outgoing result message (to a client) or result shuttle message, this replica uses the hash of 'OK', instead of the hash of the actual result, in its result statement.

drop_result_stmt(): in the next outgoing result message (to a client) or result shuttle message, omit the head's result statement from the result proof.

-----
required failures for phase 3 only:  [2017-10-09 inserted "only"]

crash(): immediately call logging.shutdown() (to flush logs to disk) and then os._exit(-1).  you need "import logging" and "import os" for this to work.

truncate_history(): in the next outgoing wedged message, send a truncated history by omitting the last entry. [phase 3 only]

sleep(time): sleep for the specified time, in milliseconds.  this is a timing failure. [phase 3 only]

drop(): drop (i.e., ignore) the incoming message that triggered this failure. [phase 3 only]

-----
configuration files should have the following format: each row either starts with "#", in which case it is a comment, or contains the name of a configuration parameter, an equals sign, and the value of that configuration parameter.  whitespace around the equals sign is optional and should be ignored.  parameters may appear in the configuration file in any order.

[2017-10-16 I deleted the section of the configuration file that dealt with mapping of processes to hosts.  since this mapping is controlled by command-line options, not DistAlgo code, it is inconvenient to specify it in the configuration file.  the command(s) used to run each test case should be included in your submission; see revised description of item (3) in entries in testing.txt.]

the following example shows the names of configuration parameters that must be supported by your system.  your system may support additional configuration parameters for your own use.

# test case name.  can be used to trigger test case specific code in client,
# e.g., to generate special request sequences or validate intermediate or
# final values of object state. [2017-09-12: added this item]
test_case_name = test1

# number of failures to tolerate.  number of replicas is 2t+1.
t = 1
# number of clients
num_client = 3
# client timeout, in milliseconds.  if timer expires, resend request 
# to all replicas, as described in section 3.3.
client_timeout = 3000
# timeout, in milliseconds, for head and non-head servers, respectively:
# if timer expires, send reconfiguration request to Olympus, as described 
# in section 3.3.
head_timeout = 3000
nonhead_timeout = 3000

# CLIENT WORKLOAD
workload[0] = pseudorandom(233,5)
workload[1] = put('movie','star'); append('movie',' wars'); get('movie')
workload[2] = put('jedi,'luke skywalker); slice('jedi','0:4'); get('jedi')

# FAILURE SCENARIO
# failures(c,r) is the failure scenario for replica r in configuration c.
# configurations are numbered starting with 0.  replicas are numbered by
# position in the chain, starting from 0.  replicas without a specified
# failure scenario are failure-free.
failures[0,0] = client_request(2,1), crash()
failures[1,2] = result_shuttle(0,1),drop(); shuttle(1,3),omit_send()

here is some code for reading a configuration file.  client workloads and failure scenarios require additional parsing.

with open('config.txt','r') as f:   [2017-10-09 changed .csv to .txt]
    for line in f:
        if line[0] != '#':
          (key,sep,val) = line.partition('=')
          # if the line does not contain '=', it is invalid and hence ignored
          if len(sep) != 0:
              val = val.strip()
              config[key.strip()] = int(val) if str.isdecimal(val) else val
print(config)

note: I was reluctant to standardize the configuration file format.  however, students in previous years recommended that demos include new instructor-supplied test cases (which is practical only with a standardized format), because some students were clever at constructing test cases that circumvented the bugs in their systems.