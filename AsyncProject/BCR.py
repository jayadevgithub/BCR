# -*- generated by 1.0.11 -*-
import da
PatternExpr_1356 = da.pat.TuplePattern([da.pat.ConstantPattern('add_client_at_replica'), da.pat.FreePattern('public_key'), da.pat.FreePattern('client_id')])
PatternExpr_1364 = da.pat.FreePattern('olympus')
PatternExpr_2497 = da.pat.TuplePattern([da.pat.ConstantPattern('wedged_request'), da.pat.FreePattern('wedge_request_id')])
PatternExpr_2504 = da.pat.FreePattern('olympus')
PatternExpr_2753 = da.pat.TuplePattern([da.pat.ConstantPattern('send_retransmitted_status'), da.pat.FreePattern('cache_key'), da.pat.FreePattern('sender_replica_id')])
PatternExpr_2762 = da.pat.FreePattern('valid_replica')
PatternExpr_2795 = da.pat.TuplePattern([da.pat.ConstantPattern('acknowledge_retransmission')])
PatternExpr_2800 = da.pat.FreePattern('tail_replica')
PatternExpr_2818 = da.pat.TuplePattern([da.pat.ConstantPattern('truncate_history_till_check_point'), da.pat.FreePattern('completed_checkpoint_proof'), da.pat.FreePattern('checkpoint_identifier')])
PatternExpr_2827 = da.pat.FreePattern('prev_replica')
PatternExpr_3122 = da.pat.TuplePattern([da.pat.ConstantPattern('initiate_checkpointing'), da.pat.FreePattern('checkpoint_proof'), da.pat.FreePattern('checkpoint_identifier')])
PatternExpr_3131 = da.pat.FreePattern('prev_replica')
PatternExpr_3435 = da.pat.TuplePattern([da.pat.ConstantPattern('terminate_replica')])
PatternExpr_3440 = da.pat.FreePattern('olympus')
PatternExpr_3459 = da.pat.TuplePattern([da.pat.ConstantPattern('print_order_proofs')])
PatternExpr_3464 = da.pat.FreePattern('client')
PatternExpr_3495 = da.pat.TuplePattern([da.pat.ConstantPattern('perform_operation'), da.pat.FreePattern('client_request'), da.pat.FreePattern('result'), da.pat.FreePattern('result_shuttle'), da.pat.FreePattern('next_slot_number')])
PatternExpr_3508 = da.pat.FreePattern('valid_process')
PatternExpr_5255 = da.pat.TuplePattern([da.pat.ConstantPattern('retransmitted_request_from_replica_to_head')])
PatternExpr_5433 = da.pat.TuplePattern([da.pat.ConstantPattern('get_running_state'), da.pat.FreePattern('running_state_id')])
PatternExpr_5440 = da.pat.FreePattern('olympus')
PatternExpr_5576 = da.pat.TuplePattern([da.pat.ConstantPattern('new_configuration'), da.pat.FreePattern('running_state')])
PatternExpr_5583 = da.pat.FreePattern('olympus')
PatternExpr_5628 = da.pat.TuplePattern([da.pat.ConstantPattern('perform_catchup_to_maximal_order_proof'), da.pat.FreePattern('catchup_message'), da.pat.FreePattern('catchup_msg_identifier')])
PatternExpr_5637 = da.pat.FreePattern('olympus')
PatternExpr_5949 = da.pat.TuplePattern([da.pat.ConstantPattern('initiating_retransmit_request'), da.pat.FreePattern('client_request')])
PatternExpr_5956 = da.pat.FreePattern('valid_process')
PatternExpr_6387 = da.pat.TuplePattern([da.pat.ConstantPattern('cache_result_shuttle'), da.pat.FreePattern('client_id'), da.pat.FreePattern('request_id'), da.pat.FreePattern('retransmit_id'), da.pat.FreePattern('result_shuttle'), da.pat.FreePattern('result')])
PatternExpr_6708 = da.pat.TuplePattern([da.pat.ConstantPattern('store_keys'), da.pat.FreePattern('public_key'), da.pat.FreePattern('private_key'), da.pat.FreePattern('public_keys')])
PatternExpr_6754 = da.pat.TuplePattern([da.pat.ConstantPattern('KeysFound')])
PatternExpr_6759 = da.pat.SelfPattern()
PatternExpr_6777 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_6782 = da.pat.SelfPattern()
PatternExpr_6762 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.SelfPattern()]), da.pat.TuplePattern([da.pat.ConstantPattern('KeysFound')])])
PatternExpr_6785 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.SelfPattern()]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_8908 = da.pat.TuplePattern([da.pat.ConstantPattern('register_client_at_olympus'), da.pat.FreePattern('public_key'), da.pat.FreePattern('client_id')])
PatternExpr_8917 = da.pat.FreePattern('client')
PatternExpr_8992 = da.pat.TuplePattern([da.pat.ConstantPattern('client_registered_at_replica'), da.pat.FreePattern('client_id'), da.pat.FreePattern('replica_id')])
PatternExpr_9001 = da.pat.FreePattern('client')
PatternExpr_10486 = da.pat.TuplePattern([da.pat.ConstantPattern('reconfigure_request'), da.pat.FreePattern('replica_id')])
PatternExpr_10493 = da.pat.FreePattern('process_cli_replica')
PatternExpr_10847 = da.pat.TuplePattern([da.pat.ConstantPattern('running_state_from_replica'), da.pat.FreePattern('replica_id'), da.pat.FreePattern('running_state')])
PatternExpr_10856 = da.pat.FreePattern('client')
PatternExpr_10871 = da.pat.TuplePattern([da.pat.ConstantPattern('caughtup_message'), da.pat.FreePattern('replica_id'), da.pat.FreePattern('caughtup_message')])
PatternExpr_10880 = da.pat.FreePattern('client')
PatternExpr_10901 = da.pat.TuplePattern([da.pat.ConstantPattern('wedged_statement_from_replica'), da.pat.FreePattern('wedged_statement'), da.pat.FreePattern('replica_id')])
PatternExpr_10910 = da.pat.FreePattern('client')
PatternExpr_10939 = da.pat.TuplePattern([da.pat.ConstantPattern('get_current_active_configuration_from_olympus'), da.pat.FreePattern('client_id')])
PatternExpr_10946 = da.pat.FreePattern('client')
PatternExpr_10984 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_10989 = da.pat.SelfPattern()
PatternExpr_10992 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.SelfPattern()]), da.pat.TuplePattern([da.pat.ConstantPattern('done')])])
PatternExpr_11440 = da.pat.TuplePattern([da.pat.ConstantPattern('received_active_configuration_at_client'), da.pat.FreePattern('replica_set'), da.pat.FreePattern('public_keys')])
PatternExpr_11448 = da.pat.FreePattern('olympus')
PatternExpr_11533 = da.pat.TuplePattern([da.pat.ConstantPattern('client_registered_at_olympus'), da.pat.FreePattern('parent_process')])
PatternExpr_11539 = da.pat.FreePattern('olympus')
PatternExpr_11563 = da.pat.TuplePattern([da.pat.ConstantPattern('last_served_request'), da.pat.FreePattern('result_shuttle')])
PatternExpr_11570 = da.pat.FreePattern('olympus')
PatternExpr_11682 = da.pat.TuplePattern([da.pat.ConstantPattern('parent_sent_result'), da.pat.FreePattern('result_parent')])
PatternExpr_11689 = da.pat.FreePattern('parent_process')
PatternExpr_11917 = da.pat.TuplePattern([da.pat.ConstantPattern('result_shuttle'), da.pat.FreePattern('result_shuttle'), da.pat.FreePattern('result'), da.pat.FreePattern('replica_id'), da.pat.FreePattern('response_request_id')])
PatternExpr_11930 = da.pat.FreePattern('tail_replica')
PatternExpr_12052 = da.pat.TuplePattern([da.pat.ConstantPattern('parent_performed_operation'), da.pat.FreePattern('globalseqid')])
PatternExpr_12059 = da.pat.FreePattern('parent_process')
PatternExpr_12125 = da.pat.TuplePattern([da.pat.ConstantPattern('client_registered_at_olympus'), da.pat.FreePattern(None)])
PatternExpr_12131 = da.pat.FreePattern('olympus')
PatternExpr_12474 = da.pat.TuplePattern([da.pat.ConstantPattern('done')])
PatternExpr_12479 = da.pat.SelfPattern()
PatternExpr_13376 = da.pat.TuplePattern([da.pat.ConstantPattern('get_result_from_parent_process'), da.pat.FreePattern('globalseqid')])
PatternExpr_13383 = da.pat.FreePattern('client')
PatternExpr_13439 = da.pat.TuplePattern([da.pat.ConstantPattern('parent_perform_operation'), da.pat.FreePattern('client_id'), da.pat.FreePattern('request_id'), da.pat.FreePattern('operation')])
PatternExpr_13450 = da.pat.FreePattern('client')
PatternExpr_13715 = da.pat.ConstantPattern('done')
PatternExpr_13719 = da.pat.SelfPattern()
PatternExpr_13722 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.SelfPattern()]), da.pat.ConstantPattern('done')])
_config_object = {}
import sys
import nacl.encoding
import nacl.signing
import nacl.hash
import uuid
import copy
import random
from random import randint
from nacl.bindings.utils import sodium_memcmp
import nacl.secret
import nacl.utils
import nacl
from nacl.public import PrivateKey, Box
import logging
import datetime
import time
import traceback
import time
import os
import itertools
timestamp = datetime.datetime.fromtimestamp(time.time()).strftime('%Y-%m-%d %H:%M:%S')

class Replica(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ReplicaReceivedEvent_16 = []
        self._ReplicaReceivedEvent_17 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_0', PatternExpr_1356, sources=[PatternExpr_1364], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1355]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_1', PatternExpr_2497, sources=[PatternExpr_2504], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2496]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_2', PatternExpr_2753, sources=[PatternExpr_2762], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2752]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_3', PatternExpr_2795, sources=[PatternExpr_2800], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2794]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_4', PatternExpr_2818, sources=[PatternExpr_2827], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2817]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_5', PatternExpr_3122, sources=[PatternExpr_3131], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3121]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_6', PatternExpr_3435, sources=[PatternExpr_3440], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3434]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_7', PatternExpr_3459, sources=[PatternExpr_3464], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3458]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_8', PatternExpr_3495, sources=[PatternExpr_3508], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3494]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_9', PatternExpr_5255, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5254]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_10', PatternExpr_5433, sources=[PatternExpr_5440], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5432]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_11', PatternExpr_5576, sources=[PatternExpr_5583], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5575]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_12', PatternExpr_5628, sources=[PatternExpr_5637], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5627]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_13', PatternExpr_5949, sources=[PatternExpr_5956], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_5948]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_14', PatternExpr_6387, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_6386]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_15', PatternExpr_6708, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_6707]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_16', PatternExpr_6754, sources=[PatternExpr_6759], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_17', PatternExpr_6777, sources=[PatternExpr_6782], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, T, replica_Set, replica_Id, config_file, configuration_id, **rest_13732):
        super().setup(T=T, replica_Set=replica_Set, replica_Id=replica_Id, config_file=config_file, configuration_id=configuration_id, **rest_13732)
        self._state.T = T
        self._state.replica_Set = replica_Set
        self._state.replica_Id = replica_Id
        self._state.config_file = config_file
        self._state.configuration_id = configuration_id
        self._state.T = self._state.T
        self._state.configuration_id = self._state.configuration_id
        self._state.Active = 'Active'
        self._state.Immutable = 'Immutable'
        self._state.client_public_keys = {}
        self._state.public_key = None
        self._state.config_file_name = self._state.config_file
        self._state.private_key = None
        self._state.data_object = {}
        self._state.replica_id = self._state.replica_Id
        self._state.mode = None
        self._state.result_cache = {}
        self._state.is_head_replica = False
        self._state.is_tail_replica = False
        self._state.replica_set = {}
        self._state.current_slot_number = 0
        self._state.result_cache = {}
        self._state.history = History()
        self._state.public_keys = None
        self._state.global_timer = {}
        self._state.client_forwarded_request_count = {}
        self._state.config = None
        self._state.failure_triggers = []
        self._state.switch = 1
        self._state.pending_change_operations = 0
        self._state.pending_change_results = 0
        self._state.pending_drop_result_stmts = 0
        self._state.pending_crash_stmts = 0
        self._state.pending_truncate_history_statements = 0
        self._state.pending_sleep_statements = 0
        self._state.pending_drop_stmts = 0
        self._state.pending_increment_slot_stmts = 0
        self._state.pending_extra_op_stmts = 0
        self._state.pending_invalid_order_stmts_signatures = 0
        self._state.pending_invalid_result_signatures = 0
        self._state.pending_drop_checkpoint_stmts = 0
        self._state.sleep_time_periods = []
        self._state.send_acks_to_replicas = {}
        self._state.retransmit_acknowledged = 0
        self._state.current_checkpoint_proof = None
        self._state.checkpoint_id = 0
        self._state.last_served_request_for_a_client = {}
        self._state.caughtup_message = None
        self._state.pending_drop_result_stmts_failure_at_tail_replica = False
        self._state.pending_change_result_failure_at_tail_replica = False
        self._state.completed_checkpoint_id = 0
        self._state.replica_state = self._state.Active
        self._state.head_replica_id = None
        self._state.tail_replica_id = None
        self.read_config()
        self.get_failure_workload()
        self._state.checkpointing_interval = self.get_check_pointing_interval('checkpt_interval')
        if (self._state.checkpointing_interval is None):
            self._state.checkpointing_interval = 999
        self._state.logger = logging.getLogger(('Replica ' + str(self._state.replica_id)))
        self._state.logger.setLevel(logging.INFO)
        self._state.olympus = None
        handler = logging.FileHandler((str(timestamp) + '_replica.log'))
        handler.setLevel(logging.INFO)
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        self._state.logger.addHandler(handler)
        self._state.logger.info(((((' for replica_id ' + str(self._state.replica_id)) + ' :-> \n') + str(self._state.failure_triggers)) + '\n'))
        if (self._state.replica_Id == 0):
            self._state.head_replica_id = self._state.replica_Id
            self._state.is_head_replica = True
            self._state.replica_timeout = self.get_timeout('head_timeout')
        elif (self._state.replica_Id == (len(self._state.replica_Set) - 1)):
            self._state.tail_replica_id = None
            self._state.is_tail_replica = True
            self._state.replica_timeout = self.get_timeout('nonhead_timeout')
        else:
            self._state.replica_timeout = self.get_timeout('nonhead_timeout')
        count = 0
        for (temp_replica_id, replica) in enumerate(self._state.replica_Set):
            self._state.replica_set[temp_replica_id] = replica
            if (count == 0):
                self._state.head_replica = replica
            elif (count == (len(self._state.replica_Set) - 1)):
                self._state.tail_replica = replica
            count = (count + 1)
        self._state.logger.info(('replica_Set ' + str(self._state.replica_set)))

    def run(self):
        super()._label('_st_label_6751', block=False)
        _st_label_6751 = 0
        while (_st_label_6751 == 0):
            _st_label_6751 += 1
            if PatternExpr_6762.match_iter(self._ReplicaReceivedEvent_16, SELF_ID=self._id):
                _st_label_6751 += 1
            else:
                super()._label('_st_label_6751', block=True)
                _st_label_6751 -= 1
        super()._label('_st_label_6774', block=False)
        _st_label_6774 = 0
        while (_st_label_6774 == 0):
            _st_label_6774 += 1
            if PatternExpr_6785.match_iter(self._ReplicaReceivedEvent_17, SELF_ID=self._id):
                _st_label_6774 += 1
            else:
                super()._label('_st_label_6774', block=True)
                _st_label_6774 -= 1

    def get_failure_workload(self):
        workload = self._state.config.get((((('failures[' + str(self._state.configuration_id)) + ',') + str(self._state.replica_id)) + ']'))
        if (workload is None):
            return
        workload = workload.split(';')
        trigger_failures = []
        for items in workload:
            items = items.strip()
            first_occur = items.find(',')
            second_occur = items.find(',', (first_occur + 1))
            if (second_occur == (- 1)):
                trigger = items[0:first_occur].strip()
                failure = items[(first_occur + 1):].strip()
                open_brace_loc = trigger.find('(')
                trigger_name = trigger[0:open_brace_loc]
                trigger_name = trigger_name.strip()
                closed_brace_occurrence = trigger.find(')')
                client_id = None
                message_id = trigger[(open_brace_loc + 1):closed_brace_occurrence]
                message_id = message_id.strip()
            else:
                trigger = items[0:second_occur].strip()
                failure = items[(second_occur + 1):].strip()
                open_brace_loc = trigger.find('(')
                trigger_name = trigger[0:open_brace_loc]
                trigger_name = trigger_name.strip()
                comma_occurrence = trigger.find(',')
                closed_brace_occurrence = trigger.find(')')
                client_id = trigger[(open_brace_loc + 1):comma_occurrence]
                client_id = client_id.strip()
                message_id = trigger[(comma_occurrence + 1):closed_brace_occurrence]
                message_id = message_id.strip()
            open_brace_loc = failure.find('(')
            closed_brace_occurrence = failure.find(')')
            failure_name = failure[0:open_brace_loc]
            failure_param = failure[(open_brace_loc + 1):closed_brace_occurrence]
            failure_name = failure_name.strip()
            if (len(failure_param) == 0):
                failure_param = None
            trigger_dict = {}
            trigger_dict['trigger_name'] = trigger_name
            trigger_dict['client_id'] = client_id
            trigger_dict['message_id'] = message_id
            trigger_dict['failure_name'] = failure_name
            trigger_dict['failure_param'] = failure_param
            self._state.failure_triggers.append(trigger_dict)

    def decode_hash_and_verify(self, hash_digest, signed_message, public_key):
        try:
            new_digest = public_key.verify(signed_message)
            if sodium_memcmp(hash_digest, new_digest):
                return True
            else:
                self._state.logger.log(('decode_hash_and_verify-failed: original ' + str(hash_digest)))
                self._state.logger.log(('decode_hash_and_verify-failed: unsigned hash' + str(new_digest)))
                return False
        except:
            self._state.logger.error('nacl.exceptions.BadSignatureError: Signature was forged or corrupt.')
        return False

    def match_hash_with_head_replica(self, replica_signed_hash, replica_public_key, head_signed_hash, head_public_key):
        try:
            replica_msg_digest = replica_public_key.verify(replica_signed_hash)
            head_msg_digest = head_public_key.verify(head_signed_hash)
            if sodium_memcmp(replica_msg_digest, head_msg_digest):
                return True
            else:
                return False
        except:
            self._state.logger.error('nacl.exceptions.BadSignatureError: Signature was forged or corrupt')
        return False

    def is_registered_client(self, client_id):
        if (client_id in self._state.client_public_keys):
            self._state.logger.info('is_registered_client: client_id=%s is registered at replica_id=%s', str(client_id), str(self._state.replica_id))
            return True
        else:
            self._state.logger.info('is_registered_client: client_id=%s is NOT registered at replica_id=%s', str(client_id), str(self._state.replica_id))
            return False

    def check_in_result_cache(self, client_id, request_id):
        self._state.logger.info('checking if result is found in result cache for client_id:%s and request_id:%s at replica_id:%s', str(client_id), str(request_id), str(self._state.replica_id))
        cache_key = ((('00000' + str(client_id)) + '11111') + str(request_id))
        if (cache_key in self._state.result_cache):
            self._state.logger.info('check_in_result_cache:found %s in result cache', str(cache_key))
            return self._state.result_cache[cache_key]
        else:
            self._state.logger.info('check_in_result_cache: %s is NOT in result cache', str(cache_key))
            return None

    def read_config(self):
        self._state.config = {}
        with open(self._state.config_file_name, 'r') as f:
            for line in f:
                if (not (line[0] == '#')):
                    (key, sep, val) = line.partition('=')
                    if (not (len(sep) == 0)):
                        val = val.strip()
                        self._state.config[key.strip()] = (int(val) if str.isdecimal(val) else val)
        self._state.config = self._state.config

    def get_timeout(self, timeout_key):
        timeout_val = self._state.config.get(timeout_key)
        timeout_val = int(timeout_val)
        timeout_val = (timeout_val / 1000)
        return timeout_val

    def get_check_pointing_interval(self, check_point_key):
        return self._state.config.get(check_point_key)

    def process_operation(self, operation):
        self._state.logger.info('replica_id=%s is processing operations', str(self._state.replica_id))
        opcode = operation['operation']
        if (opcode == 'put'):
            key = operation['key']
            value = operation['value']
            self._state.data_object[key] = value
            return 'Success'
        elif (opcode == 'get'):
            key = operation['key']
            if (not (key in self._state.data_object)):
                return 'Error'
            value = self._state.data_object[key]
            return value
        elif (opcode == 'slice'):
            key = operation['key']
            if (not (key in self._state.data_object)):
                return 'Error'
            index1 = int(operation['value1'])
            index2 = int(operation['value2'])
            value = self._state.data_object[key]
            value = value[index1:index2]
            self._state.data_object[key] = value
            return value
        elif (opcode == 'append'):
            key = operation['key']
            if (not (key in self._state.data_object)):
                return 'Error'
            value = operation['value']
            value = (self._state.data_object[key] + value)
            self._state.data_object[key] = value
            return 'Success'

    def get_next_replica(self):
        self._state.logger.info('getting next replica:%s,len_of_replica_set:%s', str((self._state.replica_id + 1)), str(len(self._state.replica_set)))
        if (self._state.replica_id == (len(self._state.replica_set) - 1)):
            return None
        else:
            return self._state.replica_set[(self._state.replica_id + 1)]

    def get_prev_replica(self):
        self._state.logger.info('getting prev replica:%s,len_of_replica_set:%s', str((self._state.replica_id - 1)), str(len(self._state.replica_set)))
        if (self._state.replica_id == 0):
            return None
        else:
            return self._state.replica_set[(self._state.replica_id - 1)]

    def validate_result_shuttle(self, result_shuttle, client_id, request_id, replica_id):
        self._state.logger.info('validate_result_shuttle:validating result shuttle for client_id:%s,request_id:%s,replica_id:%s', str(client_id), str(request_id), str(replica_id))
        curr_order_proof = result_shuttle.get_order_proof_from_shuttle()
        count_of_result_proofs = result_shuttle.get_count_of_result_proofs_in_shuttle()
        self._state.logger.info(((((((((('validate_result_shuttle: count_of_result_proofs ' + str(count_of_result_proofs)) + ' len(replica_set): ') + str(len(self._state.replica_set))) + ' client_id ') + str(client_id)) + ' request_id ') + str(request_id)) + ' replica_id ') + str(replica_id)))
        if (not (count_of_result_proofs == len(self._state.replica_set))):
            self.send(('reconfigure_request', replica_id), to=self._state.olympus)
            self._state.logger.error('calling reconfig provable case of misbehaviour detected for client_id:%s,request_id:%s,replica_id:%s result proofs are invalid-count', str(client_id), str(request_id), str(replica_id))
            return False
        self._state.head_replica_id = 0
        head_replica_result_proof = result_shuttle.get_result_proof_of_replica(self._state.head_replica_id)
        head_replica_public_key = self._state.public_keys[head_replica_result_proof.replica_id]
        head_replica_hash_digest = head_replica_result_proof.get_result_hashed_value_from_result_proof()
        head_replica_signed_digest = head_replica_result_proof.get_result_signed_value_from_result_proof()
        for index in range(1, count_of_result_proofs):
            curr_result_proof = result_shuttle.get_result_proof_of_replica(self._state.head_replica_id)
            curr_replica_public_key = self._state.public_keys[curr_result_proof.replica_id]
            curr_result_proof_hash_digest = curr_result_proof.get_result_hashed_value_from_result_proof()
            curr_result_proof_signed_hash = curr_result_proof.get_result_signed_value_from_result_proof()
            if ((not (str(head_replica_result_proof.operation) == str(curr_result_proof.operation))) or (self.decode_hash_and_verify(curr_result_proof_hash_digest, curr_result_proof_signed_hash, curr_replica_public_key) is False) or (self.match_hash_with_head_replica(curr_result_proof_signed_hash, curr_replica_public_key, head_replica_signed_digest, head_replica_public_key) is False)):
                self.send(('reconfigure_request', replica_id), to=self._state.olympus)
                self._state.logger.error('calling reconfig provable case of misbehaviour detected for client_id:%s,request_id:%s,replica_id:%s result proofs are invalid', str(client_id), str(request_id), str(replica_id))
                return False
        count_of_order_statements = curr_order_proof.get_count_of_order_statements_from_order_proof()
        head_replica_order_stmt = curr_order_proof.get_order_statement_of_replica(self._state.head_replica_id)
        head_replica_public_key = self._state.public_keys[head_replica_order_stmt.replica_id]
        head_replica_hash_digest = head_replica_order_stmt.get_hash_of_order_statement()
        head_replica_signed_digest = head_replica_order_stmt.get_signed_hash_of_order_statement()
        if (not (count_of_order_statements == len(self._state.replica_set))):
            self.send(('reconfigure_request', replica_id), to=self._state.olympus)
            self._state.logger.error('calling reconfig provable case of misbehaviour detected for client_id:%s,request_id:%s,replica_id:%s order_statements are invalid-count', str(client_id), str(request_id), str(replica_id))
            return False
        for index in range(1, count_of_order_statements):
            curr_order_statement = curr_order_proof.get_order_statement_of_replica(index)
            curr_replica_public_key = self._state.public_keys[curr_order_statement.replica_id]
            curr_order_stmt_hash_digest = curr_order_statement.get_hash_of_order_statement()
            curr_order_stmt_signed_hash = curr_order_statement.get_signed_hash_of_order_statement()
            if ((self.decode_hash_and_verify(curr_order_stmt_hash_digest, curr_order_stmt_signed_hash, curr_replica_public_key) is False) or (self.match_hash_with_head_replica(curr_order_stmt_signed_hash, curr_replica_public_key, head_replica_signed_digest, head_replica_public_key) is False)):
                self.send(('reconfigure_request', replica_id), to=self._state.olympus)
                self._state.logger.error('calling reconfig provable case of misbehaviour detected for client_id:%s,request_id:%s,replica_id:%s order_statements are invalid-count', str(client_id), str(request_id), str(replica_id))
                return False

    def change_operation_failure(self, client_request, client_id, request_id):
        self._state.logger.info(((((('changing operation for client_id' + str(client_id)) + ' request_id ') + str(request_id)) + ' replica_id ') + str(self._state.replica_id)))
        self._state.pending_change_operations = (self._state.pending_change_operations - 1)
        operation_dict = {}
        operation_dict['operation'] = 'get'
        operation_dict['key'] = 'x'
        operation_dict['value'] = None
        self._state.logger.warning('changing operation for client_id :%s,request_id:%s,replica_id:%s,new operation:%s', str(client_id), str(request_id), str(self._state.replica_id), str(operation_dict))
        client_request.set_operation(operation_dict)
        return operation_dict

    def increment_slot_number_failure(self):
        while (self._state.pending_increment_slot_stmts > 0):
            self._state.logger.warning('increment_slot: incrementing slot number for the head_replica')
            self._state.current_slot_number = (self._state.current_slot_number + 1)
            self._state.pending_increment_slot_stmts = (self._state.pending_increment_slot_stmts - 1)

    def sleep_failure(self):
        while (self._state.pending_sleep_statements > 0):
            sleep_period = self._state.sleep_time_periods[0]
            del self._state.sleep_time_periods[0]
            self._state.logger.warning(' sleep_failure: replica_id:%s sleeping for a period of %s milli seconds ', str(self._state.replica_id), str(sleep_period))
            self._state.pending_sleep_statements = (self._state.pending_sleep_statements - 1)
            sleep_period = int(sleep_period)
            sleep_period = (sleep_period / 1000)
            current_time = time.time()
            time.sleep(sleep_period)
            new_time = time.time()
            self._state.logger.warning('replica_id:%s slept for %s milli seconds and is now awake ', str(self._state.replica_id), str(sleep_period))

    def crash_failure(self):
        self._state.logger.warning('crash_failure: crashing the replica %s', str(self._state.replica_id))
        self._state.pending_crash_stmts = (self._state.pending_crash_stmts - 1)
        os._exit((- 1))

    def extra_op_failure(self):
        self._state.logger.warning("extra_op_failure: adding malicious operation put('a','a') to the replica's running state %s", str(self._state.replica_id))
        self._state.pending_extra_op_stmts = (self._state.pending_extra_op_stmts - 1)
        malicious_key = 'a'
        malicious_value = 'a'
        self._state.data_object[malicious_key] = malicious_value

    def drop_failure(self, msg, msg_id, special_msg=''):
        self._state.pending_drop_stmts = (self._state.pending_drop_stmts - 1)
        self._state.logger.warning(('drop_failure: dropping the incoming msg:%s,with %s_id:%s ' + special_msg), str(msg), str(msg), str(msg_id))

    def invalid_result_signature_failure(self, client_id, request_id, result_shuttle):
        self._state.pending_invalid_result_signatures = (self._state.pending_invalid_result_signatures - 1)
        curr_result_stmt_signed_msg = result_shuttle.get_result_proof_of_replica(self._state.replica_id).get_result_signed_value_from_result_proof()
        tampered_signed_msg = get_tampered_signed_msg(curr_result_stmt_signed_msg)
        result_shuttle.get_result_proof_of_replica(self._state.replica_id).set_result_signed_value_in_result_proof(tampered_signed_msg)
        self._state.logger.warning('invalid_result_sig: failure detected for client_id:%s,request_id:%s,replica_id:%s', str(client_id), str(request_id), str(self._state.replica_id))

    def invalid_order_statement_signature_failure(self, client_id, request_id, result_shuttle):
        self._state.logger.warning('invalid_order_sig: failure detected for client_id:%s,request_id:%s,replica_id:%s', str(client_id), str(request_id), str(self._state.replica_id))
        self._state.pending_invalid_order_stmts_signatures = (self._state.pending_invalid_order_stmts_signatures - 1)
        order_stmt = result_shuttle.get_order_proof_from_shuttle().get_order_statement_of_replica(self._state.replica_id)
        curr_order_stmt_signed_msg = order_stmt.get_signed_hash_of_order_statement()
        tampered_signed_msg = get_tampered_signed_msg(curr_order_stmt_signed_msg)
        order_stmt.set_signed_hashed_value_in_order_statement(tampered_signed_msg)

    def drop_checkpoint_stmts_failure(self, completed_checkpoint_proof, checkpoint_identifier):
        self._state.pending_drop_checkpoint_stmts = (self._state.pending_drop_checkpoint_stmts - 1)
        self._state.logger.warning('dropping thr t+1 check point stmts for checkpoint_id: %s,replica_id:%s', str(checkpoint_identifier), str(self._state.replica_id))
        for rep_id in range(0, (self._state.T + 1)):
            completed_checkpoint_proof.remove_checkpoint_proof_at_replica_id(rep_id)

    def change_result_in_result_shuttle_failure(self, client_id, request_id, result_shuttle):
        self._state.logger.warning("changing result to 'OK' message client_id:%s,request_id:%s,replica_id:%s", str(client_id), str(request_id), str(self._state.replica_id))
        self._state.pending_change_results = (self._state.pending_change_results - 1)
        tampered_result = 'OK'
        tampered_result_hash = get_hash(tampered_result)
        result_shuttle.get_result_proof_of_replica(self._state.replica_id).set_result_hashed_value_in_result_proof(tampered_result_hash)

    def drop_result_statement_of_head_replica_failure(self, client_id, request_id, result_shuttle):
        self._state.logger.warning('dropping result stmt of head_replica client_id:%s,request_id:%s,replica_id:%s', str(client_id), str(request_id), str(self._state.replica_id))
        self._state.pending_drop_result_stmts = (self._state.pending_drop_result_stmts - 1)
        self._state.logger.warning(('drop_result_statement_of_head_replica_failure: before dropping result_shuttle count_of_result_proofs ' + str(result_shuttle.get_count_of_result_proofs_in_shuttle())))
        result_shuttle.drop_result_proof_from_shuttle(self._state.head_replica_id)
        self._state.logger.warning(('drop_result_statement_of_head_replica_failure: after dropping result_shuttle count_of_result_proofs ' + str(result_shuttle.get_count_of_result_proofs_in_shuttle())))

    def validate_check_point_proofs(self, checkpoint_proof, checkpoint_identifier):
        prev_replica_id = (self._state.replica_id - 1)
        hash_of_running_state_prev_replica = checkpoint_proof.get_hash_of_running_state_of_replica(prev_replica_id)
        signed_hash_of_running_state_prev_replica = checkpoint_proof.get_signed_hash_of_running_state_of_replica(prev_replica_id)
        public_key_of_prev_replica = self._state.public_keys[prev_replica_id]
        hash_of_running_state_current_replica = checkpoint_proof.get_hash_of_running_state_of_replica(self._state.replica_id)
        signed_hash_of_running_state_current_replica = checkpoint_proof.get_signed_hash_of_running_state_of_replica(self._state.replica_id)
        public_key_of_current_replica = self._state.public_keys[self._state.replica_id]
        if ((self.decode_hash_and_verify(hash_of_running_state_prev_replica, signed_hash_of_running_state_prev_replica, public_key_of_prev_replica) is False) or (self.match_hash_with_head_replica(signed_hash_of_running_state_prev_replica, public_key_of_prev_replica, signed_hash_of_running_state_current_replica, public_key_of_current_replica) is False)):
            return False
        else:
            self._state.logger.info('checkpointproof validation is done at replica_id:%s', str(self._state.replica_id))
            return True

    def get_checkpoint_proof(self, checkpoint_identifier, checkpointing_interval):
        replica_history = self._state.history
        running_state = ''
        order_proofs = replica_history.get_order_proofs()
        slot_ids = replica_history.get_next_slot_ids(checkpoint_identifier, checkpointing_interval)
        self._state.logger.info(((((('get_checkpoint_proof:performing get_checkpoint_proof with slot_ids ' + str(slot_ids)) + ' with checkpoint_identifier') + str(checkpoint_identifier)) + ' and checkpointing_interval ') + str(checkpointing_interval)))
        for slot_id in slot_ids:
            order_proof_for_each_slot = replica_history.get_order_proof_at_slot(slot_id)
            order_statements = order_proof_for_each_slot.get_order_statements_from_order_proof()
            replica_order_statement = order_statements[self._state.replica_id]
            running_state = (running_state + replica_order_statement.get_order_statement_as_string())
        (hash_of_running_state, signed_hash_of_running_state) = encode_hash(running_state, self._state.private_key)
        return (hash_of_running_state, signed_hash_of_running_state)

    def check_in_order_proof(self, request_id):
        if (request_id <= (len(self._state.history.order_proof_for_each_slot) - 1)):
            return True
        else:
            return False

    def get_pending_failures_if_exists(self, client_id, consolidated_request_id, trigger_name):
        triggers_to_be_executed = []
        self._state.logger.info('checking_for_triggers: in replica_id=%s, with client_id=%s, request_id=%s,trigger_name=%s', str(self._state.replica_id), str(client_id), str(consolidated_request_id), str(trigger_name))
        to_be_removed = []
        for i in range(0, len(self._state.failure_triggers)):
            failure_trigger = self._state.failure_triggers[i]
            t_client_id = failure_trigger['client_id']
            t_message_id = failure_trigger['message_id']
            t_trigger_name = failure_trigger['trigger_name']
            if (((client_id is None) or (t_client_id is None) or (int(client_id) == int(t_client_id))) and (int(t_message_id) == int(consolidated_request_id)) and (trigger_name == t_trigger_name)):
                self._state.logger.info('checking_for_triggers: trigger found at replica_id=%s, with client_id=%s, request_id=%s,trigger_name=%s at index:%s', str(self._state.replica_id), str(client_id), str(consolidated_request_id), str(trigger_name), str(i))
                to_be_removed.append(i)
                triggers_to_be_executed.append(failure_trigger)
        for i in range((len(to_be_removed) - 1), (- 1), (- 1)):
            del self._state.failure_triggers[to_be_removed[i]]
        return triggers_to_be_executed

    def update_failure_count(self, failure_name, failure_param):
        if (failure_name == 'change_operation'):
            self._state.pending_change_operations = (self._state.pending_change_operations + 1)
        elif (failure_name == 'change_result'):
            self._state.pending_change_results = (self._state.pending_change_results + 1)
        elif (failure_name == 'drop_result_stmt'):
            self._state.pending_drop_result_stmts = (self._state.pending_drop_result_stmts + 1)
        elif (failure_name == 'crash'):
            self._state.pending_crash_stmts = (self._state.pending_crash_stmts + 1)
        elif (failure_name == 'truncate_history'):
            self._state.pending_truncate_history_statements = (self._state.pending_truncate_history_statements + 1)
        elif (failure_name == 'sleep'):
            self._state.pending_sleep_statements = (self._state.pending_sleep_statements + 1)
            self._state.sleep_time_periods.append(failure_param)
        elif (failure_name == 'drop'):
            self._state.pending_drop_stmts = (self._state.pending_drop_stmts + 1)
        elif (failure_name == 'increment_slot'):
            self._state.pending_increment_slot_stmts = (self._state.pending_increment_slot_stmts + 1)
        elif (failure_name == 'extra_op'):
            self._state.pending_extra_op_stmts = (self._state.pending_extra_op_stmts + 1)
        elif (failure_name == 'invalid_order_sig'):
            self._state.pending_invalid_order_stmts_signatures = (self._state.pending_invalid_order_stmts_signatures + 1)
        elif (failure_name == 'invalid_result_sig'):
            self._state.pending_invalid_result_signatures = (self._state.pending_invalid_result_signatures + 1)
        elif (failure_name == 'drop_checkpt_stmts'):
            self._state.pending_drop_checkpoint_stmts = (self._state.pending_drop_checkpoint_stmts + 1)

    def add_to_running_state(self, operation, running_state):
        self._state.logger.info('replica_id=%s is processing operations', str(self._state.replica_id))
        opcode = operation['operation']
        if (opcode == 'put'):
            key = operation['key']
            value = operation['value']
            running_state[key] = value
            return (running_state, 'Success')
        elif (opcode == 'get'):
            key = operation['key']
            if (not (key in running_state)):
                return 'Error'
            value = running_state[key]
            return (running_state, value)
        elif (opcode == 'slice'):
            key = operation['key']
            if (not (key in running_state)):
                return 'Error'
            index1 = int(operation['value1'])
            index2 = int(operation['value2'])
            value = running_state[key]
            value = value[index1:index2]
            running_state[key] = value
            return (running_state, value)
        elif (opcode == 'append'):
            key = operation['key']
            if (not (key in running_state)):
                return 'Error'
            value = operation['value']
            value = (running_state[key] + value)
            running_state[key] = value
            return (running_state, 'Success')

    def _Replica_handler_1355(self, public_key, client_id, olympus):
        self._state.olympus = olympus
        self._state.logger.info("received: 'add_client_at_replica' with client_id:%s at replica:%s FROM Olympus", str(client_id), str(self._state.replica_id))
        self._state.client_public_keys[client_id] = public_key
        self._state.client_forwarded_request_count[client_id] = 0
        self.send(('client_registered_at_replica', client_id, self._state.replica_id), to=olympus)
        self._state.logger.info("sent: 'client_registered_at_replica'- client_id=%s,at replica:%s TO Olympus", str(client_id), str(self._state.replica_id))
    _Replica_handler_1355._labels = None
    _Replica_handler_1355._notlabels = None

    def _Replica_handler_2496(self, wedge_request_id, olympus):
        self._state.logger.info(('wedged_request:inside wedged_request at ' + str(self._state.replica_id)))
        wedge_request_failures = self.get_pending_failures_if_exists(None, wedge_request_id, 'wedge_request')
        for wedge_request_failure in wedge_request_failures:
            if (not (wedge_request_failure is None)):
                self._state.logger.info('Trigger Exists:  in  replica=%s, trigger_name=wedged_request with wedge_request_id=%s, failure_to_be_executed=%s', str(self._state.replica_id), str(wedge_request_id), str(wedge_request_failure['failure_name']))
                self.update_failure_count(str(wedge_request_failure['failure_name']), wedge_request_failure['failure_param'])
                if (self._state.pending_extra_op_stmts > 0):
                    self.extra_op_failure()
                if ((self._state.is_head_replica is True) and (self._state.pending_increment_slot_stmts > 0)):
                    self.increment_slot_number_failure()
                if (self._state.pending_drop_stmts > 0):
                    self.drop_failure('wedged_request', wedge_request_id)
                    return
                if (self._state.pending_crash_stmts > 0):
                    self.crash_failure()
                if (self._state.pending_sleep_statements > 0):
                    self.sleep_failure()
        self._state.logger.info('wedged_request: received wedged request FROM olympus changing the replica status to Immutable')
        self._state.replica_state = self._state.Immutable
        self._state.logger.info('wedged_statement_from_replica: sending wedge statement to olympus making itself immutable replica_state:%s', str(self._state.replica_state))
        replica_history = copy.deepcopy(self._state.history)
        self._state.logger.info(((('wedged_request: completed_checkpoint_id  ' + str(self._state.completed_checkpoint_id)) + ' at replica_id ') + str(self._state.replica_id)))
        wedged_statement = WedgedStatement(replica_history, self._state.current_checkpoint_proof, self._state.completed_checkpoint_id)
        self._state.logger.warning(((('pre-truncate_history-failure history order_proofs at replica_id :' + str(self._state.replica_id)) + ' is ') + str(wedged_statement.get_history_from_wedged_statement().get_order_proofs())))
        if (self._state.pending_truncate_history_statements > 0):
            self._state.pending_truncate_history_statements = (self._state.pending_truncate_history_statements - 1)
            self._state.logger.warning('truncate_history: failure detected, omitting the last entry of the wedged statement wedge_request_id :%s,replica_id:%s', str(wedge_request_id), str(self._state.replica_id))
            wedged_statement.get_history_from_wedged_statement().omit_last_entry_of_history()
            self._state.logger.warning(((('post-truncate_history-failure history order_proofs at replica_id :' + str(self._state.replica_id)) + ' is ') + str(wedged_statement.get_history_from_wedged_statement().get_order_proofs())))
        self.send(('wedged_statement_from_replica', wedged_statement, self._state.replica_id), to=olympus)
    _Replica_handler_2496._labels = None
    _Replica_handler_2496._notlabels = None

    def _Replica_handler_2752(self, cache_key, sender_replica_id, valid_replica):
        self._state.logger.info('send_retransmitted_status: received from replica_id:%s', str(sender_replica_id))
        self._state.send_acks_to_replicas[cache_key] = True
        self.send(('acknowledge_retransmission',), to=valid_replica)
        self._state.logger.info('send_retransmitted_status: acknowledged replica_id:%s', str(sender_replica_id))
    _Replica_handler_2752._labels = None
    _Replica_handler_2752._notlabels = None

    def _Replica_handler_2794(self, tail_replica):
        self._state.logger.info('acknowledge_retransmission: acknowledged at replica_id:%s', str(self._state.replica_id))
        self._state.retransmit_acknowledged = 2
    _Replica_handler_2794._labels = None
    _Replica_handler_2794._notlabels = None

    def _Replica_handler_2817(self, completed_checkpoint_proof, checkpoint_identifier, prev_replica):
        self._state.logger.info(((('truncate_history_till_check_point with complete_checkpoint_identifier ' + str(checkpoint_identifier)) + ' at replica_id ') + str(self._state.replica_id)))
        self._state.current_checkpoint_proof = copy.deepcopy(completed_checkpoint_proof)
        completed_checkpoint_failures = self.get_pending_failures_if_exists(None, checkpoint_identifier, 'completed_checkpoint')
        for completed_checkpoint_failure in completed_checkpoint_failures:
            if (not (completed_checkpoint_failure is None)):
                self._state.logger.info('Trigger Exists: in  replica=%s, trigger_name=completed_checkpoint with completed_checkpoint_id=%s, failure_to_be_executed=%s', str(self._state.replica_id), str(checkpoint_identifier), str(completed_checkpoint_failure['failure_name']))
                self.update_failure_count(str(completed_checkpoint_failure['failure_name']), completed_checkpoint_failure['failure_param'])
                if (self._state.pending_extra_op_stmts > 0):
                    self.extra_op_failure()
                if ((self._state.is_head_replica is True) and (self._state.pending_increment_slot_stmts > 0)):
                    self.increment_slot_number_failure()
                if (self._state.pending_drop_stmts > 0):
                    self.drop_failure('completed_checkpoint_failure', checkpoint_identifier)
                    return
                if (self._state.pending_crash_stmts > 0):
                    self.crash_failure()
                if (self._state.pending_sleep_statements > 0):
                    self.sleep_failure()
        replica_history = self._state.history
        slot_ids = replica_history.get_next_slot_ids(checkpoint_identifier, self._state.checkpointing_interval)
        for slot_id in slot_ids:
            self._state.logger.info(((('truncate_history_till_check_point: removing order_proof at slot_id ' + str(slot_id)) + ' replica_id ') + str(self._state.replica_id)))
            replica_history.remove_order_proof_at_slot(slot_id)
        if (self._state.pending_drop_checkpoint_stmts > 0):
            self.drop_checkpoint_stmts_failure(completed_checkpoint_proof, checkpoint_identifier)
        self._state.completed_checkpoint_id = (self._state.completed_checkpoint_id + 1)
        if (self._state.is_head_replica is False):
            prev_replica = self.get_prev_replica()
            self.send(('truncate_history_till_check_point', completed_checkpoint_proof, checkpoint_identifier), to=prev_replica)
        else:
            self._state.logger.info(('truncation successfully done at all replicas replica_id:' + str(self._state.replica_id)))
    _Replica_handler_2817._labels = None
    _Replica_handler_2817._notlabels = None

    def _Replica_handler_3121(self, checkpoint_proof, checkpoint_identifier, prev_replica):
        super()._label('_st_label_3134', block=False)
        _st_label_3134 = 0
        while (_st_label_3134 == 0):
            _st_label_3134 += 1
            if ((self._state.current_slot_number % self._state.checkpointing_interval) == 0):
                _st_label_3134 += 1
            else:
                super()._label('_st_label_3134', block=True)
                _st_label_3134 -= 1
        self._state.logger.info(((('initiate_checkpointing:performing checkpoining checkpoint_identifier ' + str(checkpoint_identifier)) + ' at replica_id ') + str(self._state.replica_id)))
        if (not (checkpoint_identifier == self._state.checkpoint_id)):
            self.send(('reconfigure_request', self._state.replica_id), to=self._state.olympus)
            self._state.logger.error('initiate_checkpointing:calling reconfig provable case of misbehaviour detected for expected checkpoint_id:%s,actual_checkpoint_identifier:%s,replica_id:%s checkpoint_identifier is invalid', str(self._state.checkpoint_id), str(checkpoint_identifier), str(self._state.replica_id))
            return
        checkpoint_failures = self.get_pending_failures_if_exists(None, checkpoint_identifier, 'checkpoint')
        for checkpoint_failure in checkpoint_failures:
            if (not (checkpoint_failure is None)):
                self._state.logger.info('Trigger Exists: in  replica=%s, trigger_name=checkpoint with checkpoint_id=%s, failure_to_be_executed=%s', str(self._state.replica_id), str(checkpoint_identifier), str(checkpoint_failure['failure_name']))
                self.update_failure_count(str(checkpoint_failure['failure_name']), checkpoint_failure['failure_param'])
                if (self._state.pending_extra_op_stmts > 0):
                    self.extra_op_failure()
                if ((self._state.is_head_replica is True) and (self._state.pending_increment_slot_stmts > 0)):
                    self.increment_slot_number_failure()
                if (self._state.pending_drop_stmts > 0):
                    self.drop_failure('checkpoint_failure', checkpoint_identifier)
                    return
                if (self._state.pending_crash_stmts > 0):
                    self.crash_failure()
                if (self._state.pending_sleep_statements > 0):
                    self.sleep_failure()
        (hash_of_running_state, signed_hash_of_running_state) = self.get_checkpoint_proof(checkpoint_identifier, self._state.checkpointing_interval)
        checkpoint_proof.add_to_check_point_proof(hash_of_running_state, signed_hash_of_running_state, self._state.replica_id)
        next_replica = self.get_next_replica()
        self._state.checkpoint_id = (self._state.checkpoint_id + 1)
        if (self._state.is_tail_replica is False):
            self.send(('initiate_checkpointing', checkpoint_proof, checkpoint_identifier), to=next_replica)
        else:
            self.send(('truncate_history_till_check_point', checkpoint_proof, checkpoint_identifier), to=self._id)
    _Replica_handler_3121._labels = None
    _Replica_handler_3121._notlabels = None

    def _Replica_handler_3434(self, olympus):
        print(('process terminated replica_id' + str(self._state.replica_id)))
        os._exit((- 1))
    _Replica_handler_3434._labels = None
    _Replica_handler_3434._notlabels = None

    def _Replica_handler_3458(self, client):
        replica_history = self._state.history
        order_proofs = replica_history.get_order_proofs()
        self._state.logger.info((('replica_id: ' + str(self._state.replica_id)) + ' order_proofs: '), str(order_proofs))
    _Replica_handler_3458._labels = None
    _Replica_handler_3458._notlabels = None

    def _Replica_handler_3494(self, client_request, result, result_shuttle, next_slot_number, valid_process):
        self._state.logger.info(((((('\n\n next_slot_number from:' + str(next_slot_number)) + ' current_slot_number ') + str(self._state.current_slot_number)) + ' at replica_id ') + str(self._state.replica_id)))
        client_id = client_request.get_client_id()
        request_id = client_request.get_request_id()
        operation = client_request.get_operation()
        client_process = client_request.get_client_process_info()
        retransmitted = client_request.get_retransmitted_status()
        retransmit_id = client_request.get_retransmit_id()
        client_public_key = self._state.client_public_keys[client_id]
        hash_of_client_request = client_request.get_hash_of_client_request()
        signed_hash_of_client_request = client_request.get_signed_hash_of_client_request()
        self._state.logger.info("received: 'perform_operation' with retransmit_id=%s , client_id=%s, request_id=%s, operation=%s ,current_slot_number=%s", str(retransmit_id), str(client_id), str(request_id), str(operation), ((str(self._state.current_slot_number) + ' received from ') + str(valid_process)))
        if (self._state.replica_state == self._state.Immutable):
            self._state.logger.warning("'perform_operation' is ignored by head_replica with retransmit_id=%s , client_id=%s, request_id=%s, operation=%s ,current_slot_number=%s", str(retransmit_id), str(client_id), str(request_id), str(operation), str(self._state.current_slot_number))
            return
        if ((not (next_slot_number is None)) and (self.decode_hash_and_verify(hash_of_client_request, signed_hash_of_client_request, client_public_key) is False)):
            self._state.logger.error('perform_operation:client_request signature mismatch calling reconfig provable case of misbehaviour detected for client_id:%s,request_id:%s,replica_id:%s ', str(client_id), str(request_id), str(self._state.replica_id))
            self.send(('reconfigure_request', self._state.replica_id), to=self._state.olympus)
            self._state.logger.info("reconfigure_request: 'perform_operation' with retransmit_id=%s , client_id=%s, request_id=%s, operation=%s ,current_slot_number=%s", str(retransmit_id), str(client_id), str(request_id), str(operation), str(self._state.current_slot_number))
            return
        if ((not (next_slot_number is None)) and (not (next_slot_number == self._state.current_slot_number))):
            self._state.logger.error('perform_operation: slot_number mismatch  expected_slot:%s actual slot:%s calling reconfig provable case of misbehaviour detected for client_id:%s,request_id:%s,replica_id:%s ', str(self._state.current_slot_number), str(next_slot_number), str(client_id), str(request_id), str(self._state.replica_id))
            self.send(('reconfigure_request', self._state.replica_id), to=self._state.olympus)
            return
        if (self.is_registered_client(client_id) is False):
            self._state.logger.warning('MALICIOUS client found')
        else:
            self._state.logger.info('replica_id=%s is processing operation=%s requested by client_id=%s', str(self._state.replica_id), str(operation), str(client_id))
            if (retransmitted is True):
                self._state.client_forwarded_request_count[client_id] = (self._state.client_forwarded_request_count[client_id] + 1)
                forwarded_request_id = self._state.client_forwarded_request_count[client_id]
                pending_failures = self.get_pending_failures_if_exists(client_id, forwarded_request_id, 'forwarded_request')
                for pending_failure in pending_failures:
                    if (not (pending_failure is None)):
                        self._state.logger.info('Trigger Exists:  in  replica=%s, trigger_name=forwarded_request with client_id=%s, request_id=%s, failure_to_be_executed=%s', str(self._state.replica_id), str(client_id), str(request_id), str(pending_failure['failure_name']))
                        self.update_failure_count(str(pending_failure['failure_name']), pending_failure['failure_param'])
                        if (self._state.pending_extra_op_stmts > 0):
                            self.extra_op_failure()
                        if ((self._state.is_head_replica is True) and (self._state.pending_increment_slot_stmts > 0)):
                            self.increment_slot_number_failure()
                        if (self._state.pending_drop_stmts > 0):
                            special_msg = ((('in replica_id ' + str(self._state.replica_id)) + ' in client_id ') + str(client_id))
                            self.drop_failure('forwarded_request', forwarded_request_id, special_msg)
                            return
                        if (self._state.pending_crash_stmts > 0):
                            self.crash_failure()
                        if (self._state.pending_sleep_statements > 0):
                            self.sleep_failure()
            cache_key = ((('00000' + str(client_id)) + '11111') + str(request_id))
            if ((cache_key in self._state.result_cache) and (self._state.result_cache[cache_key] is True)):
                self._state.logger.info('operation sent to replica_id=%s  operation=%s requested by client_id=%s and request_id:%s is duplicate', str(self._state.replica_id), str(operation), str(client_id), str(request_id))
                pass
            elif (self._state.is_head_replica is True):
                client_request_failures = self.get_pending_failures_if_exists(client_id, (request_id + retransmit_id), 'client_request')
                for client_request_failure in client_request_failures:
                    if (not (client_request_failure is None)):
                        self._state.logger.info('Trigger Exists:  in  replica=%s, trigger_name=client_request with client_id=%s, request_id=%s, failure_to_be_executed=%s', str(self._state.replica_id), str(client_id), str(request_id), str(client_request_failure['failure_name']))
                        self.update_failure_count(str(client_request_failure['failure_name']), client_request_failure['failure_param'])
                        if (self._state.pending_extra_op_stmts > 0):
                            self.extra_op_failure()
                        if ((self._state.is_head_replica is True) and (self._state.pending_increment_slot_stmts > 0)):
                            self.increment_slot_number_failure()
                        if (self._state.pending_drop_stmts > 0):
                            special_msg = ((('in replica_id ' + str(self._state.replica_id)) + ' in client_id ') + str(client_id))
                            self.drop_failure('client_request', request_id, special_msg)
                            return
                        if (self._state.pending_crash_stmts > 0):
                            self.crash_failure()
                        if (self._state.pending_sleep_statements > 0):
                            self.sleep_failure()
                shuttle_failures = self.get_pending_failures_if_exists(client_id, (request_id + retransmit_id), 'shuttle')
                for shuttle_failure in shuttle_failures:
                    if (not (shuttle_failure is None)):
                        self._state.logger.info('Trigger Exists:  in  replica=%s, trigger_name=shuttle with client_id=%s, request_id=%s, failure_to_be_executed=%s', str(self._state.replica_id), str(client_id), str(request_id), str(shuttle_failure['failure_name']))
                        self.update_failure_count(str(shuttle_failure['failure_name']), shuttle_failure['failure_param'])
                        if (self._state.pending_extra_op_stmts > 0):
                            self.extra_op_failure()
                        if ((self._state.is_head_replica is True) and (self._state.pending_increment_slot_stmts > 0)):
                            self.increment_slot_number_failure()
                        if (self._state.pending_drop_stmts > 0):
                            special_msg = ((('in replica_id ' + str(self._state.replica_id)) + ' in client_id ') + str(client_id))
                            self.drop_failure('shuttle_failure', request_id, special_msg)
                            return
                        if (self._state.pending_crash_stmts > 0):
                            self.crash_failure()
                        if (self._state.pending_sleep_statements > 0):
                            self.sleep_failure()
                self._state.result_cache[cache_key] = True
                result = self.process_operation(operation)
                order_proof = OrderProof(self._state.current_slot_number, operation, self._state.replica_id)
                order_statement = OrderStatement(self._state.current_slot_number, operation, self._state.replica_id, self._state.private_key, client_id, request_id)
                order_proof.add_order_statment(self._state.replica_id, order_statement)
                self._state.history.add_order_proof_to_history(self._state.current_slot_number, order_proof)
                result_proof = ResultProof(operation, self._state.replica_id, result, self._state.private_key)
                result_shuttle = Shuttle(self._state.current_slot_number, operation)
                result_shuttle.add_result_proof_to_shuttle(self._state.replica_id, result_proof)
                result_shuttle.add_order_statement_to_order_proof_in_shuttle(self._state.replica_id, order_statement)
                self._state.last_served_request_for_a_client[client_id] = ResultCache(client_id, request_id, result, self._state.replica_id, self._state.private_key, operation)
                self._state.logger.info('last_served_request_for_a_client: replica_id:%s,request_id:%s', str(self._state.replica_id), str(request_id))
                if (self._state.pending_invalid_result_signatures > 0):
                    self.invalid_result_signature_failure(client_id, request_id, result_shuttle)
                if (self._state.pending_invalid_order_stmts_signatures > 0):
                    self.invalid_order_statement_signature_failure(client_id, request_id, result_shuttle)
                if (self._state.pending_change_operations > 0):
                    operation = self.change_operation_failure(client_request, client_id, request_id)
                next_replica = self.get_next_replica()
                self.send(('perform_operation', client_request, result, result_shuttle, self._state.current_slot_number), to=next_replica)
                self._state.logger.info("sent: 'perform_operation' TO next_replica=%s, at head_replica with client_id=%s, request_id=%s, operation=%s, sending to %s", str((self._state.replica_id + 1)), str(client_id), str(request_id), str(operation), str(next_replica))
                self._state.current_slot_number = (self._state.current_slot_number + 1)
                if ((self._state.current_slot_number % self._state.checkpointing_interval) == 0):
                    checkpoint_proof = CheckPointProof(self._state.checkpoint_id, (self._state.current_slot_number - self._state.checkpointing_interval), (self._state.current_slot_number - 1))
                    self.send(('initiate_checkpointing', checkpoint_proof, self._state.checkpoint_id), to=self._id)
            else:
                client_request_failures = self.get_pending_failures_if_exists(client_id, (request_id + retransmit_id), 'client_request')
                for client_request_failure in client_request_failures:
                    if (not (client_request_failure is None)):
                        self._state.logger.info('Trigger Exists:  in  replica=%s, trigger_name=client_request with client_id=%s, request_id=%s, failure_to_be_executed=%s', str(self._state.replica_id), str(client_id), str(request_id), str(client_request_failure['failure_name']))
                        self.update_failure_count(str(client_request_failure['failure_name']), client_request_failure['failure_param'])
                        if (self._state.pending_extra_op_stmts > 0):
                            self.extra_op_failure()
                        if ((self._state.is_head_replica is True) and (self._state.pending_increment_slot_stmts > 0)):
                            self.increment_slot_number_failure()
                        if (self._state.pending_drop_stmts > 0):
                            special_msg = ((('in replica_id ' + str(self._state.replica_id)) + ' in client_id ') + str(client_id))
                            self.drop_failure('client_request', request_id, special_msg)
                            return
                        if (self._state.pending_crash_stmts > 0):
                            self.crash_failure()
                        if (self._state.pending_sleep_statements > 0):
                            self.sleep_failure()
                shuttle_failures = self.get_pending_failures_if_exists(client_id, (request_id + retransmit_id), 'shuttle')
                for i in range(0, len(shuttle_failures)):
                    shuttle_failure = shuttle_failures[i]
                    if (not (shuttle_failure is None)):
                        self._state.logger.info('Trigger Exists:  in  replica=%s, trigger_name=shuttle with client_id=%s, request_id=%s, failure_to_be_executed=%s', str(self._state.replica_id), str(client_id), str(request_id), str(shuttle_failure['failure_name']))
                        self.update_failure_count(str(shuttle_failure['failure_name']), shuttle_failure['failure_param'])
                        if (self._state.pending_extra_op_stmts > 0):
                            self.extra_op_failure()
                        if ((self._state.is_head_replica is True) and (self._state.pending_increment_slot_stmts > 0)):
                            self.increment_slot_number_failure()
                        if (self._state.pending_drop_stmts > 0):
                            special_msg = ((('in replica_id ' + str(self._state.replica_id)) + ' in client_id ') + str(client_id))
                            self.drop_failure('shuttle_failure', request_id, special_msg)
                            return
                        if (self._state.pending_crash_stmts > 0):
                            self.crash_failure()
                        if (self._state.pending_sleep_statements > 0):
                            self.sleep_failure()
                result = self.process_operation(operation)
                order_proof = result_shuttle.get_clone_of_order_proof_from_shuttle()
                order_proof.set_replica_id_in_order_proof(self._state.replica_id)
                order_statement = OrderStatement(self._state.current_slot_number, operation, self._state.replica_id, self._state.private_key, client_id, request_id)
                order_proof.add_order_statment(self._state.replica_id, order_statement)
                self._state.history.add_order_proof_to_history(self._state.current_slot_number, order_proof)
                result_proof = ResultProof(operation, self._state.replica_id, result, self._state.private_key)
                result_shuttle.add_result_proof_to_shuttle(self._state.replica_id, result_proof)
                result_shuttle.add_order_statement_to_order_proof_in_shuttle(self._state.replica_id, order_statement)
                self._state.last_served_request_for_a_client[client_id] = ResultCache(client_id, request_id, result, self._state.replica_id, self._state.private_key, operation)
                self._state.logger.info('last_served_request_for_a_client: replica_id:%s,request_id:%s', str(self._state.replica_id), str(request_id))
                if (self._state.pending_invalid_result_signatures > 0):
                    self.invalid_result_signature_failure(client_id, request_id, result_shuttle)
                if (self._state.pending_change_operations > 0):
                    operation = self.change_operation_failure(client_request, client_id, request_id)
                if (self._state.pending_invalid_order_stmts_signatures > 0):
                    self.invalid_order_statement_signature_failure(client_id, request_id, result_shuttle)
                if (self._state.is_tail_replica is True):
                    if (self._state.replica_state == self._state.Immutable):
                        return
                    if (self._state.pending_change_results > 0):
                        self._state.pending_change_result_failure_at_tail_replica = True
                        self.change_result_in_result_shuttle_failure(client_id, request_id, result_shuttle)
                    if (self._state.pending_drop_result_stmts > 0):
                        self._state.pending_drop_result_stmts_failure_at_tail_replica = True
                        self.drop_result_statement_of_head_replica_failure(client_id, request_id, result_shuttle)
                    self.send(('cache_result_shuttle', client_id, request_id, retransmit_id, result_shuttle, result), to=self._id)
                    self.send(('result_shuttle', result_shuttle, result, self._state.replica_id, request_id), to=client_process)
                    self._state.logger.info("sent: 'result_shuttle' TO client_id=%s with result:%s, replica_id:%s,request_id:%s", str(client_id), str(result), str(self._state.replica_id), str(request_id))
                    if ((retransmitted is True) or (cache_key in self._state.send_acks_to_replicas)):
                        self._state.logger.info("sent: 'retransmitted_request_from_replica_to_head' TO all the replicas")
                        self.send(('retransmitted_request_from_replica_to_head',), to=self._state.replica_set.values())
                    self._state.logger.info("sent: 'cache_result_shuttle' TO replica_id=%s, with client_id=%s, request_id=%s and result_shuttle", str(self._state.replica_id), str(client_id), str(request_id))
                else:
                    next_replica = self.get_next_replica()
                    self.send(('perform_operation', client_request, result, result_shuttle, self._state.current_slot_number), to=next_replica)
                    self._state.logger.info("sent: 'perform_operation' TO next_replica=%s, with client_id=%s, request_id=%s, operation=%s,, sending to %s", str((self._state.replica_id + 1)), str(client_id), str(request_id), str(operation), str(next_replica))
                self._state.current_slot_number = (self._state.current_slot_number + 1)
    _Replica_handler_3494._labels = None
    _Replica_handler_3494._notlabels = None

    def _Replica_handler_5254(self):
        self._state.logger.info('retransmitted: request is successfully done for replica_id=%s', str(self._state.replica_id))
        self._state.switch = 2
    _Replica_handler_5254._labels = None
    _Replica_handler_5254._notlabels = None

    def _Replica_handler_5432(self, running_state_id, olympus):
        self._state.logger.info('get_running_state: from replica_id=%s', str(self._state.replica_id))
        running_state_failures = self.get_pending_failures_if_exists(None, running_state_id, 'get_running_state')
        for running_state_failure in running_state_failures:
            if (not (running_state_failure is None)):
                self._state.logger.info('Trigger Exists: in  replica=%s, trigger_name=get_running_state with running_state_id=%s, failure_to_be_executed=%s', str(self._state.replica_id), str(running_state_id), str(running_state_failure['failure_name']))
                self.update_failure_count(str(running_state_failure['failure_name']), running_state_failure['failure_param'])
                if (self._state.pending_extra_op_stmts > 0):
                    self.extra_op_failure()
                if ((self._state.is_head_replica is True) and (self._state.pending_increment_slot_stmts > 0)):
                    self.increment_slot_number_failure()
                if (self._state.pending_drop_stmts > 0):
                    self.drop_failure('get_running_state', running_state_id)
                    empty_running_state = {}
                    self.send(('running_state_from_replica', self._state.replica_id, empty_running_state), to=olympus)
                    return
                if (self._state.pending_crash_stmts > 0):
                    self.crash_failure()
                if (self._state.pending_sleep_statements > 0):
                    self.sleep_failure()
        running_state = self._state.caughtup_message.get_running_state()
        self.send(('running_state_from_replica', self._state.replica_id, running_state), to=olympus)
    _Replica_handler_5432._labels = None
    _Replica_handler_5432._notlabels = None

    def _Replica_handler_5575(self, running_state, olympus):
        self._state.logger.info('new_configuration: saving running_state sent by olympus at running_state=%s replica_id=%s', str(running_state), str(self._state.replica_id))
        if (self._state.pending_extra_op_stmts > 0):
            self.extra_op_failure()
        if ((self._state.is_head_replica is True) and (self._state.pending_increment_slot_stmts > 0)):
            self.increment_slot_number_failure()
        self._state.data_object = running_state
    _Replica_handler_5575._labels = None
    _Replica_handler_5575._notlabels = None

    def _Replica_handler_5627(self, catchup_message, catchup_msg_identifier, olympus):
        self._state.logger.info('perform_catchup_to_maximal_order_proof: to replica_id=%s', str(self._state.replica_id))
        catchup_msg_failures = self.get_pending_failures_if_exists(None, catchup_msg_identifier, 'catch_up')
        for catchup_msg_failure in catchup_msg_failures:
            if (not (catchup_msg_failure is None)):
                self._state.logger.info('Trigger Exists: in  replica=%s, trigger_name=catch_up with catchup_msg_identifier=%s, failure_to_be_executed=%s', str(self._state.replica_id), str(catchup_msg_identifier), str(catchup_msg_failure['failure_name']))
                self.update_failure_count(str(catchup_msg_failure['failure_name']), catchup_msg_failure['failure_param'])
                if (self._state.pending_extra_op_stmts > 0):
                    self.extra_op_failure()
                if ((self._state.is_head_replica is True) and (self._state.pending_increment_slot_stmts > 0)):
                    self.increment_slot_number_failure()
                if (self._state.pending_drop_stmts > 0):
                    self.drop_failure('catchup_message', catchup_msg_identifier)
                    self._state.caughtup_message = CaughtUpMessage((- 1))
                    self.send(('caughtup_message', self._state.replica_id, self._state.caughtup_message), to=olympus)
                    return
                if (self._state.pending_crash_stmts > 0):
                    self.crash_failure()
                if (self._state.pending_sleep_statements > 0):
                    self.sleep_failure()
        temp_last_served_request_for_a_client = copy.deepcopy(self._state.last_served_request_for_a_client)
        running_state = copy.deepcopy(self._state.data_object)
        slot_ids = catchup_message.get_slot_ids()
        self._state.logger.info(((((((('slot_ids ' + str(slot_ids)) + ' replica_id ') + str(self._state.replica_id)) + ' history.slots ') + str(self._state.history.get_slots())) + ' running_state ') + str(running_state)))
        for slot_id in slot_ids:
            catchup_statement = catchup_message.get_catchup_statement_at_slot_id(slot_id)
            operation = catchup_statement.get_operation_in_catchup_statement()
            client_id = catchup_statement.get_operation_requested_client_id()
            request_id = catchup_statement.get_request_id_sent_by_client()
            (running_state, result) = self.add_to_running_state(operation, running_state)
            temp_last_served_request_for_a_client[client_id] = ResultCache(client_id, request_id, result, self._state.replica_id, self._state.private_key, operation)
            self._state.logger.info(((((('last_served_request_for_a_client ' + str(temp_last_served_request_for_a_client[0].get_result())) + ' at replica_id ') + str(self._state.replica_id)) + ' request_id is') + str(request_id)))
        self._state.caughtup_message = CaughtUpMessage(self._state.replica_id)
        self._state.caughtup_message.add_running_state(running_state, self._state.private_key)
        for client_id in temp_last_served_request_for_a_client:
            result_statement = temp_last_served_request_for_a_client[client_id]
            self._state.caughtup_message.add_last_served_request_result_statement(client_id, result_statement)
        self._state.caughtup_message = self._state.caughtup_message
        self._state.logger.info((((' replica_id ' + str(self._state.replica_id)) + ' running_state ') + str(running_state)))
        self.send(('caughtup_message', self._state.replica_id, self._state.caughtup_message), to=olympus)
    _Replica_handler_5627._labels = None
    _Replica_handler_5627._notlabels = None

    def _Replica_handler_5948(self, client_request, valid_process):
        client_id = client_request.get_client_id()
        request_id = client_request.get_request_id()
        operation = client_request.get_operation()
        client_process = client_request.get_client_process_info()
        retransmit_id = client_request.get_retransmit_id()
        self._state.logger.info("received: 'initiating_retransmit_request' by replica_id=%s, with client_id=%s, request_id=%s, operation=%s", str(self._state.replica_id), str(client_id), str(request_id), str(operation))
        if (self._state.replica_state == self._state.Immutable):
            self._state.logger.info('replica is immutable,wont process requests anymore')
            return
        if (self.is_registered_client(client_id) is False):
            self._state.logger.warning('MALICIOUS client found')
        else:
            if (self._state.pending_extra_op_stmts > 0):
                self.extra_op_failure()
            cache_key = ((('00000' + str(client_id)) + '11111') + str(request_id))
            self._state.logger.info('replica_id=%s is processing the retransmitted operation FROM client_id=%s', str(self._state.replica_id), str(client_id))
            cached_object = self.check_in_result_cache(request_id, client_id)
            if ((not (cached_object is None)) and (not (cached_object == True))):
                result_shuttle = cached_object.result_shuttle
                result = cached_object.result
                self.send(('result_shuttle', result_shuttle, result, self._state.replica_id, request_id), to=client_process)
                self._state.logger.info("sent: 'result_shuttle' TO client_id=%s, with result shuttle and reslut=%s", str(client_id), str(result))
            elif (self._state.is_head_replica is True):
                if (self._state.pending_increment_slot_stmts > 0):
                    self.increment_slot_number_failure()
                self.send(('send_retransmitted_status', cache_key, self._state.replica_id), to=self._state.tail_replica)
                self._state.retransmit_acknowledged = 1
                super()._label('_st_label_6139', block=False)
                _st_label_6139 = 0
                while (_st_label_6139 == 0):
                    _st_label_6139 += 1
                    if (self._state.retransmit_acknowledged == 2):
                        _st_label_6139 += 1
                    else:
                        super()._label('_st_label_6139', block=True)
                        _st_label_6139 -= 1
                if (self.check_in_order_proof(request_id) is False):
                    self.send(('perform_operation', client_request, None, None, None), to=self._state.head_replica)
                    self._state.switch = 1
                    self._state.logger.info("retransmitting_to_head_replica: 'perform_operation' with client_id=%s, request_id=%s, operation=%s TO head_replica", str(client_id), str(request_id), str(operation))
                    super()._label('_st_label_6180', block=False)
                    _st_label_6180 = 0
                    self._timer_start()
                    while (_st_label_6180 == 0):
                        _st_label_6180 += 1
                        if (self._state.switch == 2):
                            pass
                            _st_label_6180 += 1
                        elif self._timer_expired:
                            self.send(('reconfigure_request', self._state.replica_id), to=self._state.olympus)
                            self._state.logger.warning((((((('initiating_retransmit_request: retransmit failed for client_id:' + str(client_id)) + ' request_id:') + str(request_id)) + ' retransmit_id: ') + str(retransmit_id)) + ' send reconfiguration request'))
                            _st_label_6180 += 1
                        else:
                            super()._label('_st_label_6180', block=True, timeout=self._state.replica_timeout)
                            _st_label_6180 -= 1
                else:
                    self._state.logger.info('head_replica:waiting for operation to processed with client_id=%s, request_id=%s, operation=%s ,retransmit_id=%s', str(client_id), str(request_id), str(operation), str(retransmit_id))
                    self._state.switch = 1
                    super()._label('_st_label_6242', block=False)
                    _st_label_6242 = 0
                    self._timer_start()
                    while (_st_label_6242 == 0):
                        _st_label_6242 += 1
                        if (self._state.switch == 2):
                            pass
                            _st_label_6242 += 1
                        elif self._timer_expired:
                            self.send(('reconfigure_request', self._state.replica_id), to=self._state.olympus)
                            self._state.logger.warning((((((('initiating_retransmit_request: retransmit failed for client_id:' + str(client_id)) + ' request_id:') + str(request_id)) + ' retransmit_id: ') + str(retransmit_id)) + ' send reconfiguration request'))
                            _st_label_6242 += 1
                        else:
                            super()._label('_st_label_6242', block=True, timeout=self._state.replica_timeout)
                            _st_label_6242 -= 1
            else:
                self._state.logger.info(((('send_retransmitted_status: cache_key ' + str(cache_key)) + ' at replica_id ') + str(self._state.replica_id)))
                self.send(('send_retransmitted_status', cache_key, self._state.replica_id), to=self._state.tail_replica)
                self._state.retransmit_acknowledged = 1
                super()._label('_st_label_6309', block=False)
                _st_label_6309 = 0
                while (_st_label_6309 == 0):
                    _st_label_6309 += 1
                    if (self._state.retransmit_acknowledged == 2):
                        _st_label_6309 += 1
                    else:
                        super()._label('_st_label_6309', block=True)
                        _st_label_6309 -= 1
                self._state.logger.info("retransmitting_to_head_replica: 'perform_operation' with client_id=%s, request_id=%s, operation=%s TO head_replica", str(client_id), str(request_id), str(operation))
                self.send(('perform_operation', client_request, None, None, None), to=self._state.head_replica)
                (self._state.switch == 1)
                super()._label('_st_label_6345', block=False)
                _st_label_6345 = 0
                self._timer_start()
                while (_st_label_6345 == 0):
                    _st_label_6345 += 1
                    if (self._state.switch == 2):
                        pass
                        _st_label_6345 += 1
                    elif self._timer_expired:
                        self.send(('reconfigure_request', self._state.replica_id), to=self._state.olympus)
                        self._state.logger.warning((((((('initiating_retransmit_request: retransmit failed for client_id:' + str(client_id)) + ' request_id:') + str(request_id)) + ' retransmit_id: ') + str(retransmit_id)) + ' send reconfiguration request'))
                        _st_label_6345 += 1
                    else:
                        super()._label('_st_label_6345', block=True, timeout=self._state.replica_timeout)
                        _st_label_6345 -= 1
    _Replica_handler_5948._labels = None
    _Replica_handler_5948._notlabels = None

    def _Replica_handler_6386(self, client_id, request_id, retransmit_id, result_shuttle, result):
        if (self._state.replica_state == self._state.Immutable):
            self._state.logger.info(((('inside: cache_result_shuttle, replica_id ' + str(self._state.replica_id)) + ' is immutable ') + ' caching will stop'))
            return
        self._state.logger.info("received: 'cache_result_shuttle' with client_id=%s, request_id=%s,  at replica=%s result_shuttle and result=%s", str(client_id), str(request_id), str(self._state.replica_id), str(result))
        if (self.validate_result_shuttle(result_shuttle, client_id, request_id, self._state.replica_id) is False):
            self._state.logger.info('result validation failed for request_id=%s FROM client_id=%s', str(request_id), str(client_id))
            return
        else:
            self._state.logger.info('result validation successful')
        cache_key = ((('00000' + str(client_id)) + '11111') + str(request_id))
        cachedObject = CachedResult(result, result_shuttle)
        self._state.result_cache[cache_key] = cachedObject
        result_shuttle_failures = self.get_pending_failures_if_exists(client_id, (request_id + retransmit_id), 'result_shuttle')
        for result_shuttle_failure in result_shuttle_failures:
            if (not (result_shuttle_failure is None)):
                self._state.logger.info('Trigger Exists:  in  replica=%s, trigger_name=result_shuttle with client_id=%s, request_id=%s, failure_to_be_executed=%s', str(self._state.replica_id), str(client_id), str(request_id), str(result_shuttle_failure['failure_name']))
                self.update_failure_count(str(result_shuttle_failure['failure_name']), result_shuttle_failure['failure_param'])
                if (self._state.pending_extra_op_stmts > 0):
                    self.extra_op_failure()
                if ((self._state.is_head_replica is True) and (self._state.pending_increment_slot_stmts > 0)):
                    self.increment_slot_number_failure()
                if (self._state.pending_drop_stmts > 0):
                    special_msg = ((('in replica_id ' + str(self._state.replica_id)) + ' in client_id ') + str(client_id))
                    self.drop_failure('result_shuttle', request_id, special_msg)
                    return
                if (self._state.pending_crash_stmts > 0):
                    self.crash_failure()
                if (self._state.pending_sleep_statements > 0):
                    self.sleep_failure()
        if ((self._state.pending_change_results > 0) or (self._state.pending_change_result_failure_at_tail_replica is True)):
            self._state.pending_change_result_failure_at_tail_replica = False
            self.change_result_in_result_shuttle_failure(client_id, request_id, result_shuttle)
        if (self._state.pending_drop_result_stmts > 0):
            self._state.pending_drop_result_stmts_failure_at_tail_replica = False
            self.drop_result_statement_of_head_replica_failure(client_id, request_id, result_shuttle)
        if (self._state.is_head_replica is False):
            prev_replica = self.get_prev_replica()
            self.send(('cache_result_shuttle', client_id, request_id, retransmit_id, result_shuttle, result), to=prev_replica)
            self._state.logger.info("sent: 'cache_result_shuttle' with client_id=%s, request_id=%s, result=%s TO previous replica_id=%s", str(client_id), str(request_id), str(result), str((self._state.replica_id - 1)))
        else:
            self._state.logger.info('CACHING done for all replicas for request_id=%s FROM client_id=%s', str(request_id), str(client_id))
    _Replica_handler_6386._labels = None
    _Replica_handler_6386._notlabels = None

    def _Replica_handler_6707(self, public_key, private_key, public_keys):
        self._state.logger.info("received: 'store_keys' from Olympus")
        self._state.public_key = public_key
        self._state.private_key = private_key
        self._state.public_keys = public_keys
        self.send(('KeysFound',), to=self._id)
        self._state.logger.info("sent: 'KeysFound' to self")
    _Replica_handler_6707._labels = None
    _Replica_handler_6707._notlabels = None

def get_max(a, b):
    if (a > b):
        return a
    else:
        return b

def get_hash(msg):
    HASHER = nacl.hash.sha256
    msg_in_bytes = str(msg).encode('utf-8')
    dgst = HASHER(msg_in_bytes, encoder=nacl.encoding.HexEncoder)
    return dgst

def get_tampered_signed_msg(signed_message):
    signedlist = list(signed_message)
    signedlist[0] = ((signedlist[0] + 1) % 256)
    newsigned = bytes(signedlist)
    invalid_signed = nacl.signing.SignedMessage._from_parts(signed_message._signature, signed_message._message, newsigned)
    return invalid_signed

def get_signed_hash(msg, private_key):
    HASHER = nacl.hash.sha256
    msg_in_bytes = str(msg).encode('utf-8')
    dgst = HASHER(msg_in_bytes, encoder=nacl.encoding.HexEncoder)
    signed_message = private_key.sign(dgst)
    return signed_message

def compare_signed_messages(signed_message1, signed_message2):
    try:
        if sodium_memcmp(signed_message1, signed_message2):
            return True
        else:
            return False
    except:
        print('nacl.exceptions.BadSignatureError: Signature was forged or corrupt.')
    return False

def encode_hash(msg, private_key):
    HASHER = nacl.hash.sha256
    msg_in_bytes = str(msg).encode('utf-8')
    dgst = HASHER(msg_in_bytes, encoder=nacl.encoding.HexEncoder)
    signed_message = private_key.sign(dgst)
    return (dgst, signed_message)

class ResultCache():

    def __init__(self, client_id, request_id, result, cached_by_replica_id, replica_private_key, operation):
        self.client_id = client_id
        self.request_id = request_id
        self.result = result
        self.operation = operation
        self.cached_by_replica_id = cached_by_replica_id
        (self.result_hashed_value, self.result_signed_value) = encode_hash(result, replica_private_key)

    def get_result_signed_value_from_result_proof(self):
        return self.result_signed_value

    def get_result_hashed_value_from_result_proof(self):
        return self.result_hashed_value

    def get_client_id(self):
        return self.client_id

    def get_request_id(self):
        return self.request_id

    def get_result(self):
        return self.result

class CaughtUpMessage():

    def __init__(self, replica_id):
        self.replica_id = replica_id
        self.last_served_request_for_a_client = {}
        self.running_state = None
        self.hash_of_running_state = None
        self.signed_hash_of_running_state = None

    def add_running_state(self, running_state, private_key):
        self.running_state = running_state
        concatenated_msg = str(running_state)
        (self.hash_of_running_state, self.signed_hash_of_running_state) = encode_hash(concatenated_msg, private_key)

    def add_last_served_request_result_statement(self, client_id, result_proof):
        self.last_served_request_for_a_client[client_id] = result_proof

    def get_last_result_statement_of_client_at_replica(self, client_id):
        if (len(self.last_served_request_for_a_client) > 0):
            return self.last_served_request_for_a_client[client_id]
        else:
            return None

    def get_hash_of_running_state(self):
        return self.hash_of_running_state

    def get_signed_hash_of_running_state(self):
        return self.signed_hash_of_running_state

    def get_running_state(self):
        return self.running_state

class ClientRequest():

    def __init__(self, client_id, request_id, retransmit_id, operation, private_key, client_process):
        self.client_id = client_id
        self.request_id = request_id
        self.retransmit_id = retransmit_id
        self.operation = operation
        self.retransmitted = False
        self.client_process = client_process
        concatenated_msg = ((str(client_id) + str(operation)) + str(request_id))
        (self.hash_request, self.signed_hash_request) = encode_hash(concatenated_msg, private_key)

    def set_retransmitted_id(self, retransmit_id):
        self.retransmit_id = retransmit_id
        self.retransmitted = True

    def get_client_id(self):
        return self.client_id

    def get_request_id(self):
        return self.request_id

    def get_retransmit_id(self):
        return self.retransmit_id

    def get_operation(self):
        return self.operation

    def get_retransmitted_status(self):
        return self.retransmitted

    def get_client_process_info(self):
        return self.client_process

    def set_operation(self, operation):
        self.operation = operation

    def get_hash_of_client_request(self):
        concatenated_msg = ((str(self.client_id) + str(self.operation)) + str(self.request_id))
        return get_hash(concatenated_msg)

    def get_signed_hash_of_client_request(self):
        return self.signed_hash_request

class CatchupMessage():

    def __init__(self):
        self.catchup_statements = {}

    def add_order_statement(self, slot_id, catchup_statement):
        self.catchup_statements[slot_id] = catchup_statement

    def get_slot_ids(self):
        return self.catchup_statements.keys()

    def get_catchup_statement_at_slot_id(self, slot_id):
        return self.catchup_statements[slot_id]

class CatchupStatement():

    def __init__(self, order_stmt):
        self.slot = order_stmt.get_slot_in_order_statement()
        self.operation = copy.deepcopy(order_stmt.get_operation_in_order_statement())
        self.operation_requested_by = order_stmt.get_operation_requested_client_id()
        self.request_id = order_stmt.get_request_id_sent_by_client()

    def get_slot_in_catchup_statement(self):
        return self.slot

    def get_operation_in_catchup_statement(self):
        return self.operation

    def get_operation_requested_client_id(self):
        return self.operation_requested_by

    def get_request_id_sent_by_client(self):
        return self.request_id

class CheckPoint():

    def __init__(self, hash_of_running_state, signed_hash_of_running_state):
        self.hash_of_running_state = hash_of_running_state
        self.signed_hash_of_running_state = signed_hash_of_running_state

    def get_hash_of_running_state_of_replica(self):
        return self.hash_of_running_state

    def get_signed_hash_of_running_state_of_replica(self):
        return self.signed_hash_of_running_state

class CheckPointProof():

    def __init__(self, checkpoint_identifier, start_slot_id, end_slot_id):
        self.checkpoint_id = checkpoint_identifier
        self.start_slot_id = start_slot_id
        self.end_slot_id = end_slot_id
        self.checkpoint_of_replicas = {}
        self.replica_id = None

    def add_to_check_point_proof(self, hash_of_running_state, signed_hash_of_running_state, replica_id):
        self.replica_id = replica_id
        checkpoint = CheckPoint(hash_of_running_state, signed_hash_of_running_state)
        self.checkpoint_of_replicas[replica_id] = checkpoint

    def get_check_point_terminal_slot_id(self):
        return self.end_slot_id

    def get_hash_of_running_state_of_replica(self, replica_id):
        return self.checkpoint_of_replicas[replica_id].get_hash_of_running_state_of_replica()

    def get_signed_hash_of_running_state_of_replica(self, replica_id):
        return self.checkpoint_of_replicas[replica_id].get_signed_hash_of_running_state_of_replica()

    def get_count_of_replicas_with_checkpoint(self):
        return len(self.checkpoint_of_replicas)

    def get_replicas_in_checkpoint(self):
        return self.checkpoint_of_replicas.keys()

    def remove_checkpoint_proof_at_replica_id(self, replica_id):
        del self.checkpoint_of_replicas[replica_id]

class History():

    def __init__(self):
        self.order_proof_for_each_slot = {}
        self.slot_ids_cache = []

    def get_maximum_slot_id(self):
        if (len(self.slot_ids_cache) is 0):
            return 0
        else:
            return self.slot_ids_cache[(len(self.slot_ids_cache) - 1)]

    def add_order_proof_to_history(self, slot_id, order_proof):
        self.order_proof_for_each_slot[slot_id] = order_proof
        self.slot_ids_cache.append(slot_id)

    def get_order_proofs(self):
        return self.order_proof_for_each_slot

    def remove_order_proof_at_slot(self, slot_id):
        del self.order_proof_for_each_slot[slot_id]

    def get_order_proof_at_slot(self, slot_id):
        if (slot_id in self.order_proof_for_each_slot):
            return self.order_proof_for_each_slot[slot_id]
        else:
            print('**** get_order_proof_at_slot: check why it is getting called get_order_proof_at_slot***')
            return None

    def get_slots(self):
        return self.slot_ids_cache

    def get_count_of_slots(self):
        return len(self.order_proof_for_each_slot)

    def omit_last_entry_of_history(self):
        last_slot_id = self.get_maximum_slot_id()
        print((((' last_slot_id is ' + str(last_slot_id)) + ' order_proof_for_each_slot ') + str(self.order_proof_for_each_slot)))
        if (not (last_slot_id is None)):
            del self.order_proof_for_each_slot[last_slot_id]
            del self.slot_ids_cache[(len(self.slot_ids_cache) - 1)]

    def get_next_slot_ids(self, checkpoint_identifier, checkpointing_interval):
        slot_ids = self.get_slots()
        left_range = (checkpoint_identifier * checkpointing_interval)
        right_range = (left_range + checkpointing_interval)
        req_list = slot_ids[left_range:right_range]
        return req_list

class CachedResult():

    def __init__(self, result, result_shuttle):
        self.result = result
        self.result_shuttle = result_shuttle

class WedgedStatement():

    def __init__(self, history, check_point_proof, checkpoint_identifier):
        self.history = history
        self.checkpoint_proof = check_point_proof
        self.checkpoint_id = checkpoint_identifier

    def get_history_from_wedged_statement(self):
        return self.history

    def get_last_check_point_proof(self):
        return self.checkpoint_proof

    def get_checkpoint_id(self):
        return self.checkpoint_id

    def get_maximum_slot_id(self):
        return self.history.get_maximum_slot_id()

    def get_order_proof_at_slot(self, slot_id):
        return self.history.get_order_proof_at_slot(slot_id)

class ResultShuttle():

    def __init__(self):
        self.result_proofs = {}
        self.client_id = None
        self.request_id = None
        self.result = None

    def add_result_proof_at_replica_id(self, replica_id, cached_result):
        self.result_proofs[replica_id] = cached_result
        if (not (cached_result is None)):
            self.client_id = cached_result.get_client_id()
            self.request_id = cached_result.get_request_id()
            self.result = cached_result.get_result()

    def get_result_proof_of_replica(self, replica_id):
        return self.result_proofs[replica_id]

    def get_replica_ids_from_shuttle(self):
        return self.result_proofs.keys()

    def get_count_of_replica_ids_from_shuttle(self):
        return len(self.result_proofs)

    def get_client_id(self):
        return self.client_id

    def get_request_id(self):
        return self.request_id

    def get_result(self):
        return self.result

class ResultProof():

    def __init__(self, operation, replica_id, result, private_key):
        self.operation = operation
        self.replica_id = replica_id
        self.result = result
        (self.result_hashed_value, self.result_signed_value) = encode_hash(result, private_key)

    def get_result_signed_value_from_result_proof(self):
        return self.result_signed_value

    def get_result_hashed_value_from_result_proof(self):
        return self.result_hashed_value

    def get_operation_from_result_proof(self):
        return self.operation

    def set_result_signed_value_in_result_proof(self, new_signed_value):
        self.result_signed_value = new_signed_value

    def set_result_hashed_value_in_result_proof(self, tampered_result_hash_msg):
        self.result_hashed_value = tampered_result_hash_msg

class OrderStatement():

    def __init__(self, slot, operation, replica_id, private_key, client_id, request_id):
        self.slot = slot
        self.operation = operation
        concatenated_msg = (str(slot) + str(operation))
        (self.hash_operation, self.signed_hash) = encode_hash(concatenated_msg, private_key)
        self.replica_id = replica_id
        self.operation_requested_by = client_id
        self.request_id = request_id

    def get_order_statement_as_string(self):
        concatenated_msg = (str(self.slot) + str(self.operation))
        return concatenated_msg

    def get_slot_in_order_statement(self):
        return self.slot

    def get_operation_in_order_statement(self):
        return self.operation

    def get_hash_of_order_statement(self):
        return self.hash_operation

    def get_signed_hash_of_order_statement(self):
        return self.signed_hash

    def get_operation_requested_client_id(self):
        return self.operation_requested_by

    def get_request_id_sent_by_client(self):
        return self.request_id

    def set_signed_hashed_value_in_order_statement(self, tampered_signed_hash_msg):
        self.signed_hash = tampered_signed_hash_msg

class Shuttle():

    def __init__(self, slot, operation=None):
        self.order_proof = OrderProof(slot, operation, None)
        self.result_proofs = {}

    def add_order_statement_to_order_proof_in_shuttle(self, replica_id, order_statement):
        new_order_statement = copy.deepcopy(order_statement)
        self.order_proof.add_order_statment(replica_id, new_order_statement)

    def add_result_proof_to_shuttle(self, replica_id, result_proof):
        self.result_proofs[replica_id] = result_proof

    def get_result_proofs_from_shuttle(self):
        return self.result_proofs

    def get_replica_ids_from_shuttle(self):
        return self.result_proofs.keys()

    def get_result_proof_of_replica(self, replica_id):
        return self.result_proofs[replica_id]

    def get_clone_of_order_proof_from_shuttle(self):
        new_order_proof = copy.deepcopy(self.order_proof)
        return new_order_proof

    def get_order_proof_from_shuttle(self):
        return self.order_proof

    def get_count_of_result_proofs_in_shuttle(self):
        return len(self.result_proofs)

    def drop_result_proof_from_shuttle(self, replica_id):
        if (len(self.result_proofs) > 0):
            del self.result_proofs[replica_id]
        else:
            print('error_result_proof_method: result proofs is empty')

class OrderProof():

    def __init__(self, slot, operation, replica_id):
        self.slot = slot
        self.operation = operation
        self.replica_id = replica_id
        self.order_statements = {}

    def add_order_statment(self, replica_id, order_statement):
        self.order_statements[replica_id] = order_statement

    def set_replica_id_in_order_proof(self, replica_id):
        self.replica_id = replica_id

    def get_order_statements_from_order_proof(self):
        return self.order_statements

    def get_count_of_order_statements_from_order_proof(self):
        return len(self.order_statements)

    def get_order_statement_of_replica(self, replica_id):
        return self.order_statements[replica_id]

class Olympus(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._OlympusReceivedEvent_7 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_0', PatternExpr_8908, sources=[PatternExpr_8917], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_8907]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_1', PatternExpr_8992, sources=[PatternExpr_9001], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_8991]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_2', PatternExpr_10486, sources=[PatternExpr_10493], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_10485]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_3', PatternExpr_10847, sources=[PatternExpr_10856], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_10846]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_4', PatternExpr_10871, sources=[PatternExpr_10880], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_10870]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_5', PatternExpr_10901, sources=[PatternExpr_10910], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_10900]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_6', PatternExpr_10939, sources=[PatternExpr_10946], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_10938]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_7', PatternExpr_10984, sources=[PatternExpr_10989], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, T, count, config_file, **rest_13732):
        super().setup(T=T, count=count, config_file=config_file, **rest_13732)
        self._state.T = T
        self._state.count = count
        self._state.config_file = config_file
        self._state.Active = 'Active'
        self._state.Immutable = 'Immutable'
        self._state.config_file_name = self._state.config_file
        self._state.client_info = {}
        self._state.replica_set = {}
        self._state.public_keys = {}
        self._state.private_keys = {}
        self._state.count_of_registrations = {}
        self._state.count_of_wedged_statements = 0
        self._state.count_of_caughtup_messages = 0
        self._state.caughtup_messages_of_replicas = {}
        self._state.client_process_info = {}
        self._state.logger = logging.getLogger('Olympus:')
        self._state.logger.setLevel(logging.INFO)
        self._state.handler = logging.FileHandler((str(timestamp) + '_olympus.log'))
        self._state.wedged_statements = {}
        self._state.handler.setLevel(logging.INFO)
        self._state.formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        self._state.handler.setFormatter(self._state.formatter)
        self._state.logger.addHandler(self._state.handler)
        self._state.T = self._state.T
        self._state.has_received_running_state_from_random_replica = 0
        self._state.consistent_signed_hash_of_running_state = None
        self._state.current_running_state = None
        self._state.parent_process = None
        self._state.head_replica = None
        self._state.tail_replica = None
        self._state.total_replica_count = ((2 * self._state.T) + 1)
        self._state.configuration_id = 0
        self.setup_replicas()
        self.setup_parentprocess()

    def run(self):
        c = self.logical_clock()
        self.send_cryptographic_keys_to_replicas()
        super()._label('_st_label_10981', block=False)
        _st_label_10981 = 0
        while (_st_label_10981 == 0):
            _st_label_10981 += 1
            if PatternExpr_10992.match_iter(self._OlympusReceivedEvent_7, SELF_ID=self._id):
                _st_label_10981 += 1
            else:
                super()._label('_st_label_10981', block=True)
                _st_label_10981 -= 1

    def setup_parentprocess(self):
        self._state.parent_process = self.new(ParentProcess, num=1)
        self._setup(self._state.parent_process, (self._state.total_replica_count,))
        self._state.logger.info('Starting ParentProcess')
        self._start(self._state.parent_process)

    def reinitialize_setup_info_in_olympus(self):
        self._state.replica_set = {}
        self._state.public_keys = {}
        self._state.private_keys = {}
        self._state.count_of_registrations = {}
        self._state.count_of_wedged_statements = 0
        self._state.count_of_caughtup_messages = 0
        self._state.caughtup_messages_of_replicas = {}
        self._state.wedged_statements = {}
        self._state.has_received_running_state_from_random_replica = 0
        self._state.consistent_signed_hash_of_running_state = None
        self._state.current_running_state = None
        self._state.head_replica = None
        self._state.tail_replica = None
        self._state.configuration_id = (self._state.configuration_id + 1)
        for client_id in self._state.client_info:
            self._state.count_of_registrations[client_id] = 0

    def setup_replicas(self):
        self._state.logger.info('setup_replicas:creating new replicas')
        replica_list = self.new(Replica, num=self._state.total_replica_count)
        replica_id = 0
        for replica in replica_list:
            self._setup(replica, (self._state.T, replica_list, replica_id, self._state.config_file_name, self._state.configuration_id))
            self._state.replica_set[replica_id] = replica
            if (replica_id == 0):
                self._state.head_replica = replica
            elif (replica_id == (len(replica_list) - 1)):
                self._state.tail_replica = replica
            replica_id = (replica_id + 1)
        self._start(replica_list)
        self._state.logger.info('%s Replicas started', str(self._state.total_replica_count))
        print(('replica_list ' + str(replica_list)))
        for replica_id in range(0, ((2 * self._state.T) + 1)):
            key = nacl.utils.random(nacl.secret.SecretBox.KEY_SIZE)
            naclObject = nacl.signing.SigningKey(key)
            private_key = naclObject.generate()
            public_key = private_key.verify_key
            self._state.public_keys[replica_id] = public_key
            self._state.private_keys[replica_id] = private_key

    def send_cryptographic_keys_to_replicas(self):
        for replica_id in range(0, ((2 * self._state.T) + 1)):
            self.send(('store_keys', self._state.public_keys[replica_id], self._state.private_keys[replica_id], self._state.public_keys), to=self._state.replica_set[replica_id])
            self._state.logger.info("sent: 'store_keys' TO replica_id=%s", str(replica_id))

    def initialize_replicas_with_running_state(self, running_state):
        for replica_id in range(0, ((2 * self._state.T) + 1)):
            self.send(('new_configuration', running_state), to=self._state.replica_set[replica_id])
            self._state.logger.info("sent: new_configuration. with 'running_state' TO replica_id=%s", str(replica_id))

    def register_clients_at_replica(self):
        for client_id in self._state.client_info:
            public_key = self._state.client_info[client_id]
            self.send(('add_client_at_replica', public_key, client_id), to=self._state.replica_set.values())
            self._state.logger.info("sent: 'add_client_at_replica'-client_id=%s, TO all the replicas", str(client_id))

    def decode_hash_and_verify(self, hash_digest, signed_message, public_key):
        try:
            new_digest = public_key.verify(signed_message)
            if sodium_memcmp(hash_digest, new_digest):
                return True
            else:
                return False
        except:
            self._state.logger.error('nacl.exceptions.BadSignatureError: Signature was forged or corrupt.')
        return False

    def match_hash_with_max_replica(self, replica_signed_hash, replica_public_key, head_signed_hash, head_public_key):
        try:
            replica_msg_digest = replica_public_key.verify(replica_signed_hash)
            head_msg_digest = head_public_key.verify(head_signed_hash)
            if sodium_memcmp(replica_msg_digest, head_msg_digest):
                return True
            else:
                return False
        except:
            self._state.logger.error('nacl.exceptions.BadSignatureError: Signature was forged or corrupt')
        return False

    def get_max_checkpoint_value(self, checkpoint_indices):
        max_val = checkpoint_indices[0]
        for i in range(0, len(checkpoint_indices)):
            max_val = get_max(max_val, checkpoint_indices[i])
        return max_val

    def get_the_slot_to_start_catchup_process(self):
        checkpoint_indices = []
        rep_indices = []
        for replica_index in self._state.wedged_statements:
            replica_wedged_statement = self._state.wedged_statements[replica_index]
            rep_indices.append(replica_index)
            if (replica_wedged_statement.get_last_check_point_proof() is None):
                checkpoint_indices.append((- 1))
            else:
                replica_checkpoint_id = replica_wedged_statement.get_checkpoint_id()
                checkpoint_indices.append(replica_checkpoint_id)
        max_checkpt_value = self.get_max_checkpoint_value(checkpoint_indices)
        while (max_checkpt_value > 0):
            if (max_checkpt_value == (- 1)):
                return None
            wedged_replica_indices = []
            for rep_index in range(0, len(checkpoint_indices)):
                if (checkpoint_indices[rep_index] == max_checkpt_value):
                    wedged_replica_indices.append(rep_indices[rep_index])
                    checkpoint_indices[rep_index] = (- 1)
            self._state.logger.info(('wedged_replica_indices  ' + str(wedged_replica_indices)))
            for replica_index in wedged_replica_indices:
                self._state.logger.info(('wedged_statements  ' + str(self._state.wedged_statements)))
                replica_wedged_statement = self._state.wedged_statements[replica_index]
                self._state.logger.info(('wedged_statements ' + str(self._state.wedged_statements)))
                checkpoint_proof = replica_wedged_statement.get_last_check_point_proof()
                count_of_replicas_in_check_point_proof = checkpoint_proof.get_count_of_replicas_with_checkpoint()
                self._state.logger.info(('count_of_replicas_in_check_point_proof ' + str(count_of_replicas_in_check_point_proof)))
                if (count_of_replicas_in_check_point_proof < (self._state.T + 1)):
                    self._state.logger.error('Invalid checkpoint proof,checkpoint proof is not complete,missing replica proofs')
                    continue
                replica_list = list(checkpoint_proof.get_replicas_in_checkpoint())
                self._state.logger.info((' replicas in the checkpoint proof ' + str(replica_list)))
                prev_replica_id = None
                is_a_valid_check_point_proof = True
                for rep_id in replica_list:
                    self._state.logger.info(('iterating checkpoint-Proof ' + str(rep_id)))
                    if (prev_replica_id is None):
                        prev_replica_id = rep_id
                        continue
                    hash_of_running_state_prev_replica = checkpoint_proof.get_hash_of_running_state_of_replica(prev_replica_id)
                    signed_hash_of_running_state_prev_replica = checkpoint_proof.get_signed_hash_of_running_state_of_replica(prev_replica_id)
                    public_key_of_prev_replica = self._state.public_keys[prev_replica_id]
                    hash_of_running_state_current_replica = checkpoint_proof.get_hash_of_running_state_of_replica(rep_id)
                    signed_hash_of_running_state_current_replica = checkpoint_proof.get_signed_hash_of_running_state_of_replica(rep_id)
                    public_key_of_current_replica = self._state.public_keys[rep_id]
                    if ((self.decode_hash_and_verify(hash_of_running_state_prev_replica, signed_hash_of_running_state_prev_replica, public_key_of_prev_replica) is False) or (self.match_hash_with_max_replica(signed_hash_of_running_state_prev_replica, public_key_of_prev_replica, signed_hash_of_running_state_current_replica, public_key_of_current_replica) is False)):
                        is_a_valid_check_point_proof = False
                        break
                if (is_a_valid_check_point_proof is True):
                    self._state.logger.info(((((('replica_index is ' + str(replica_index)) + 'is_a_valid_check_point_proof:') + str(is_a_valid_check_point_proof)) + ' terminal slot id is ') + str(checkpoint_proof.get_check_point_terminal_slot_id())))
                    return checkpoint_proof.get_check_point_terminal_slot_id()
            max_checkpt_value = self.get_max_checkpoint_value(checkpoint_indices)

    def get_maximal_order_proof_replica_index(self, faulty_replica_indices):
        self._state.logger.info(('get_maximal_order_proof_replica_index: ' + str(self._state.wedged_statements)))
        max_slot_id = (- 1)
        max_order_proof_replica_index = None
        for replica_index in self._state.wedged_statements:
            if (replica_index in faulty_replica_indices):
                continue
            replica_wedged_statement = self._state.wedged_statements[replica_index]
            replica_history = replica_wedged_statement.get_history_from_wedged_statement()
            max_slot_num_at_replica = replica_history.get_maximum_slot_id()
            if ((not (max_slot_num_at_replica is None)) and (max_slot_id < max_slot_num_at_replica)):
                max_slot_id = max_slot_num_at_replica
                max_order_proof_replica_index = replica_index
        self._state.logger.info('returning get_maximal_order_proof_replica_index:')
        return max_order_proof_replica_index

    def print_catchup_messages(self, catup_msgs):
        self._state.logger.info('inside print_catchup_messages \n\n')
        for replica_id in catup_msgs:
            catup_msg = catup_msgs[replica_id]
            for slot_ide in catup_msg.get_slot_ids():
                self._state.logger.info(((('replica_id ' + str(replica_id)) + ' slot_ide ') + str(slot_ide)))
        self._state.logger.info('outside print_catchup_messages \n\n')

    def get_combinations(self, max_rep_id):
        available_replicas = list(self._state.wedged_statements.keys())
        available_replicas.remove(max_rep_id)
        combinations = []
        for comb in itertools.combinations(available_replicas, self._state.T):
            combinations.append(list(comb))
        return combinations

    def get_valid_quorum_of_replicas(self, max_order_proof_replica_index, slot_id_to_start_from, quorum_of_replicas):
        self._state.logger.info(((('get_valid_quorum_of_replicas: T Replicas: ' + str(quorum_of_replicas)) + ' max_order_proof_replica_index ') + str(max_order_proof_replica_index)))
        valid_quorum_of_replicas = []
        valid_quorum_of_replicas.append(max_order_proof_replica_index)
        catchup_messages = {}
        catchup_messages[max_order_proof_replica_index] = CatchupMessage()
        max_wedged_statement = self._state.wedged_statements[max_order_proof_replica_index]
        max_replica_public_key = self._state.public_keys[max_order_proof_replica_index]
        max_count_of_slots = max_wedged_statement.get_maximum_slot_id()
        self._state.logger.info(((((('get_valid_quorum_of_replicas: max  replica_index is  ' + str(max_order_proof_replica_index)) + ' with max slots ') + str(max_count_of_slots)) + ' and slot cache is ') + str(max_wedged_statement.get_history_from_wedged_statement().get_slots())))
        for replica_index in quorum_of_replicas:
            self._state.logger.info(('get_valid_quorum_of_replicas:comparing with replica_index ' + str(replica_index)))
            if (replica_index == max_order_proof_replica_index):
                pass
            else:
                current_wedged_statement = self._state.wedged_statements[replica_index]
                curr_order_proofs_size = current_wedged_statement.get_maximum_slot_id()
                curr_replica_public_key = self._state.public_keys[replica_index]
                is_a_quorum_replica = True
                self._state.logger.info(((((((((('get_valid_quorum_of_replicas:inside comparing' + str(max_order_proof_replica_index)) + ' with  replica_index ') + str(replica_index)) + ' in the range of slots ') + str(slot_id_to_start_from)) + ' to ') + str(curr_order_proofs_size)) + ' actual slot cache is ') + str(self._state.wedged_statements[replica_index].get_history_from_wedged_statement().get_slots())))
                for slot_id in range(slot_id_to_start_from, curr_order_proofs_size):
                    self._state.logger.info(('get_valid_quorum_of_replicas:checking at slot_id ' + str(slot_id)))
                    curr_order_proof = current_wedged_statement.get_order_proof_at_slot(slot_id)
                    if (curr_order_proof is None):
                        self._state.logger.info(((('get_valid_quorum_of_replicas:no order proof in replica_id ' + str(replica_index)) + ' at slot_id ') + str(slot_id)))
                        is_a_quorum_replica = False
                        break
                    max_order_proof = max_wedged_statement.get_order_proof_at_slot(slot_id)
                    curr_order_stmt = curr_order_proof.get_order_statement_of_replica(replica_index)
                    max_order_stmt = max_order_proof.get_order_statement_of_replica(max_order_proof_replica_index)
                    curr_hash_of_order_stmt = curr_order_stmt.get_hash_of_order_statement()
                    curr_signed_hash_of_order_stmt = curr_order_stmt.get_signed_hash_of_order_statement()
                    max_hash_of_order_stmt = max_order_stmt.get_hash_of_order_statement()
                    max_signed_hash_of_order_stmt = max_order_stmt.get_signed_hash_of_order_statement()
                    if ((self.decode_hash_and_verify(curr_hash_of_order_stmt, curr_signed_hash_of_order_stmt, curr_replica_public_key) is False) or (self.match_hash_with_max_replica(curr_signed_hash_of_order_stmt, curr_replica_public_key, max_signed_hash_of_order_stmt, max_replica_public_key) is False)):
                        self._state.logger.info(((('get_valid_quorum_of_replicas: no order proof in replica_id ' + str(replica_index)) + ' at slot_id ') + str(slot_id)))
                        self._state.logger.info(('get_valid_quorum_of_replicas: curr_hash_of_order_stmt ' + str(curr_hash_of_order_stmt)))
                        self._state.logger.info(('get_valid_quorum_of_replicas: max_hash_of_order_stmt ' + str(max_hash_of_order_stmt)))
                        is_a_quorum_replica = False
                        break
                if (is_a_quorum_replica is True):
                    valid_quorum_of_replicas.append(replica_index)
                    catchup_length = (max_count_of_slots - curr_order_proofs_size)
                    catchup_message = CatchupMessage()
                    self._state.logger.info(((((('get_valid_quorum_of_replicas:inside comparing' + str(max_order_proof_replica_index)) + ' with  replica_index ') + str(replica_index)) + ' with catchup length') + str(catchup_length)))
                    self._state.logger.info(('get_valid_quorum_of_replicas:get_order_proof_at_slot ' + str(max_wedged_statement.get_history_from_wedged_statement().get_slots())))
                    if (catchup_length > 0):
                        for slot_id in range((curr_order_proofs_size + 1), (max_count_of_slots + 1)):
                            self._state.logger.info(('get_valid_quorum_of_replicas:get_order_proof_at_slot ' + str(slot_id)))
                            max_order_proof = max_wedged_statement.get_order_proof_at_slot(slot_id)
                            catchup_order_stmt = max_order_proof.get_order_statement_of_replica(max_order_proof_replica_index)
                            catchup_stmt = CatchupStatement(catchup_order_stmt)
                            catchup_message.add_order_statement(slot_id, catchup_stmt)
                    catchup_messages[replica_index] = catchup_message
                if (len(valid_quorum_of_replicas) == (self._state.T + 1)):
                    return (valid_quorum_of_replicas, catchup_messages)
        return (valid_quorum_of_replicas, catchup_messages)

    def check_ordering_of_slots(self, max_wedged_statement_slots):
        prev_slot = None
        for i in range(0, len(max_wedged_statement_slots)):
            if (prev_slot is None):
                prev_slot = max_wedged_statement_slots[i]
            elif (not ((prev_slot + 1) == max_wedged_statement_slots[i])):
                return False
            else:
                prev_slot = max_wedged_statement_slots[i]
        return True

    def find_quorum_of_replicas(self):
        while (len(self._state.wedged_statements) > self._state.T):
            self._state.logger.info('inside find_quorum_of_replicas')
            checkpoint_terminal_slot_id = self.get_the_slot_to_start_catchup_process()
            self._state.logger.info(('***checkpoint_terminal_slot_id ' + str(checkpoint_terminal_slot_id)))
            if (not (checkpoint_terminal_slot_id is None)):
                next_slot_id = (checkpoint_terminal_slot_id + 1)
            else:
                next_slot_id = 0
            valid_quorum_of_replicas = []
            faulty_replica_indices = []
            catchup_messages = None
            max_order_proof_replica_index = None
            while True:
                max_order_proof_replica_index = self.get_maximal_order_proof_replica_index(faulty_replica_indices)
                if (max_order_proof_replica_index is None):
                    self._state.logger.error('find_quorum_of_replicas:Quorum of T+1 valid replicas doesnot exist')
                    break
                max_wedged_statement_slots = self._state.wedged_statements[max_order_proof_replica_index].get_history_from_wedged_statement().get_slots()
                if (self.check_ordering_of_slots(max_wedged_statement_slots) is False):
                    del self._state.wedged_statements[max_order_proof_replica_index]
                    faulty_replica_indices.append(max_order_proof_replica_index)
                    continue
                quorums_of_replicas = self.get_combinations(max_order_proof_replica_index)
                self._state.logger.info(((('find_quorum_of_replicas: getting combinations max_order_proof replica index ' + str(max_order_proof_replica_index)) + ' quorums_of_replicas ') + str(quorums_of_replicas)))
                for i in range(0, len(quorums_of_replicas)):
                    quorum_of_replicas = quorums_of_replicas[i]
                    (valid_quorum_of_replicas, catchup_messages) = self.get_valid_quorum_of_replicas(max_order_proof_replica_index, next_slot_id, quorum_of_replicas)
                    catchup_msg_identifier = 0
                    for rep_id in valid_quorum_of_replicas:
                        self._state.logger.info(('find_quorum_of_replicas:getting catchup messages from replica_id:' + str(rep_id)))
                        if (not (catchup_messages is None)):
                            catchup_message = catchup_messages[rep_id]
                        else:
                            self._state.logger.info(('find_quorum_of_replicas : catchup_message is None ' + str(catchup_messages)))
                        replica_to = self._state.replica_set[rep_id]
                        self._state.logger.info('find_quorum_of_replicas:sending perform_catchup_to_maximal_order_proof')
                        self.send(('perform_catchup_to_maximal_order_proof', catchup_message, catchup_msg_identifier), to=replica_to)
                    super()._label('_st_label_10286', block=False)
                    _st_label_10286 = 0
                    while (_st_label_10286 == 0):
                        _st_label_10286 += 1
                        if (self._state.count_of_caughtup_messages == len(valid_quorum_of_replicas)):
                            _st_label_10286 += 1
                        else:
                            super()._label('_st_label_10286', block=True)
                            _st_label_10286 -= 1
                    else:
                        if (_st_label_10286 != 2):
                            continue
                    if (_st_label_10286 != 2):
                        break
                    if (self.validate_runningstate_in_caughtup_messages() is True):
                        self._state.logger.info('find_quorum_of_replicas:Validation Successful,Quorum of T+1 valid replicas found')
                        quorum_of_replicas = copy.deepcopy(valid_quorum_of_replicas)
                        valid_running_state = None
                        running_state_id = 0
                        while (len(quorum_of_replicas) > 0):
                            random_replica_index = randint(0, (len(quorum_of_replicas) - 1))
                            replica_id = quorum_of_replicas[random_replica_index]
                            self.send(('get_running_state', running_state_id), to=self._state.replica_set[replica_id])
                            self._state.has_received_running_state_from_random_replica = 0
                            super()._label('_st_label_10352', block=False)
                            _st_label_10352 = 0
                            while (_st_label_10352 == 0):
                                _st_label_10352 += 1
                                if (self._state.has_received_running_state_from_random_replica == 1):
                                    _st_label_10352 += 1
                                else:
                                    super()._label('_st_label_10352', block=True)
                                    _st_label_10352 -= 1
                            else:
                                if (_st_label_10352 != 2):
                                    continue
                            if (_st_label_10352 != 2):
                                break
                            caughtup_message = self._state.caughtup_messages_of_replicas[replica_id]
                            del quorum_of_replicas[random_replica_index]
                            replica_running_state = self._state.current_running_state
                            replica_signed_hash_of_running_state = get_signed_hash(replica_running_state, self._state.private_keys[replica_id])
                            if (compare_signed_messages(replica_signed_hash_of_running_state, self._state.consistent_signed_hash_of_running_state) is True):
                                valid_running_state = replica_running_state
                                break
                        if (valid_running_state is None):
                            self._state.logger.info('running_states are not consistent,need to do abort the system')
                        else:
                            self.send(('terminate_replica',), to=self._state.replica_set.values())
                            self._state.logger.info(('performing reconfiguration with valid running_state ' + str(valid_running_state)))
                            self.perform_reconfiguration(valid_running_state)
                            return
                    else:
                        self._state.logger.info('validate_runningstate_in_caughtup_messages failed')
                        self._state.count_of_caughtup_messages = 0
                        self._state.caughtup_messages_of_replicas = {}
                del self._state.wedged_statements[max_order_proof_replica_index]
                if (len(valid_quorum_of_replicas) == (self._state.T + 1)):
                    self._state.logger.info('find_quorum_of_replicas:find_quorum_of_replicas:T+1 replicas found ')
                    break
                faulty_replica_indices.append(max_order_proof_replica_index)
            if (max_order_proof_replica_index is None):
                self._state.logger.info('find_quorum_of_replicas:Quorum of T+1 valid replicas doesnot exist need to terminate')
            self._state.logger.info(('find_quorum_of_replicas:Valid Quorum of replicas found ' + str(valid_quorum_of_replicas)))

    def perform_reconfiguration(self, running_state):
        client_process_info_temp = copy.deepcopy(self._state.client_process_info)
        caughtup_messages_of_replicas_temp = copy.deepcopy(self._state.caughtup_messages_of_replicas)
        self.reinitialize_setup_info_in_olympus()
        self.setup_replicas()
        self.send_cryptographic_keys_to_replicas()
        self.initialize_replicas_with_running_state(running_state)
        self.register_clients_at_replica()
        self._state.logger.info('perform_reconfiguration:clients registration done')
        for client_id in client_process_info_temp:
            shuttle = ResultShuttle()
            print(('client_id ' + str(client_id)))
            for replica_id in caughtup_messages_of_replicas_temp:
                caughtup_message = caughtup_messages_of_replicas_temp[replica_id]
                result_statement = caughtup_message.get_last_result_statement_of_client_at_replica(client_id)
                shuttle.add_result_proof_at_replica_id(replica_id, result_statement)
            client_process = client_process_info_temp[client_id]
            super()._label('_st_label_10637', block=False)
            _st_label_10637 = 0
            while (_st_label_10637 == 0):
                _st_label_10637 += 1
                if (self._state.count_of_registrations[client_id] == len(self._state.replica_set)):
                    _st_label_10637 += 1
                else:
                    super()._label('_st_label_10637', block=True)
                    _st_label_10637 -= 1
            else:
                if (_st_label_10637 != 2):
                    continue
            if (_st_label_10637 != 2):
                break
            self.send(('last_served_request', shuttle), to=client_process)
        self._state.logger.info('perform_reconfiguration:before configuration_status ')

    def validate_runningstate_in_caughtup_messages(self):
        self._state.logger.info('validate_runningstate_in_caughtup_messages:')
        prev_replica_hash_of_running_state = None
        prev_replica_signed_hash_of_running_state = None
        prev_replica_public_key = None
        for replica_id in self._state.caughtup_messages_of_replicas:
            caughtup_message = self._state.caughtup_messages_of_replicas[replica_id]
            replica_hash_of_running_state = caughtup_message.get_hash_of_running_state()
            replica_running_state = caughtup_message.get_running_state()
            self._state.logger.info(((((('validate_runningstate_in_caughtup_messages: replica_id: ' + str(replica_id)) + ' hash of running_state ') + str(replica_hash_of_running_state)) + ' running_state ') + str(replica_running_state)))
        for replica_id in self._state.caughtup_messages_of_replicas:
            caughtup_message = self._state.caughtup_messages_of_replicas[replica_id]
            if (prev_replica_hash_of_running_state is None):
                prev_replica_hash_of_running_state = caughtup_message.get_hash_of_running_state()
                prev_replica_signed_hash_of_running_state = caughtup_message.get_signed_hash_of_running_state()
                prev_replica_public_key = self._state.public_keys[replica_id]
                if (self.decode_hash_and_verify(prev_replica_hash_of_running_state, prev_replica_signed_hash_of_running_state, prev_replica_public_key) is False):
                    self._state.logger.info('validate_runningstate_in_caughtup_messages:caughtup_messages signature mismatch')
                    return False
                continue
            curr_replica_hash_of_running_state = caughtup_message.get_hash_of_running_state()
            curr_replica_signed_hash_of_running_state = caughtup_message.get_signed_hash_of_running_state()
            curr_replica_public_key = self._state.public_keys[replica_id]
            if ((self.decode_hash_and_verify(curr_replica_hash_of_running_state, curr_replica_signed_hash_of_running_state, curr_replica_public_key) is False) or (self.match_hash_with_max_replica(curr_replica_signed_hash_of_running_state, curr_replica_public_key, prev_replica_signed_hash_of_running_state, prev_replica_public_key) is False)):
                self._state.logger.info(('validate_runningstate_in_caughtup_messages:prev_replica_hash_of_running_state ' + str(prev_replica_hash_of_running_state)))
                self._state.logger.info(('validate_runningstate_in_caughtup_messages:curr_replica_hash_of_running_state ' + str(curr_replica_hash_of_running_state)))
                self._state.logger.info('validate_runningstate_in_caughtup_messages:caughtup_messages mismatch')
                return False
            else:
                prev_replica_hash_of_running_state = curr_replica_hash_of_running_state
                prev_replica_signed_hash_of_running_state = curr_replica_signed_hash_of_running_state
                prev_replica_public_key = curr_replica_public_key
        self._state.consistent_signed_hash_of_running_state = prev_replica_signed_hash_of_running_state
        return True

    def _Olympus_handler_8907(self, public_key, client_id, client):
        self._state.logger.info("received: 'register_client_at_olympus' FROM client_id=%s", str(client_id))
        self._state.client_info[client_id] = public_key
        self._state.client_process_info[client_id] = client
        self._state.count_of_registrations[client_id] = 0
        self.send(('add_client_at_replica', public_key, client_id), to=self._state.replica_set.values())
        self._state.logger.info("sent: 'add_client_at_replica'-client_id=%s, TO all the replicas", str(client_id))
        super()._label('_st_label_8966', block=False)
        _st_label_8966 = 0
        while (_st_label_8966 == 0):
            _st_label_8966 += 1
            if (self._state.count_of_registrations[client_id] == len(self._state.replica_set)):
                _st_label_8966 += 1
            else:
                super()._label('_st_label_8966', block=True)
                _st_label_8966 -= 1
        self.send(('client_registered_at_olympus', self._state.parent_process), to=client)
        self._state.logger.info("sent: 'client_registered_at_olympus' TO client_id=%s", str(client_id))
    _Olympus_handler_8907._labels = None
    _Olympus_handler_8907._notlabels = None

    def _Olympus_handler_8991(self, client_id, replica_id, client):
        self._state.logger.info('client_registered_at_replica: client:%s,at the replica:%s', str(client_id), str(replica_id))
        self._state.count_of_registrations[client_id] = (self._state.count_of_registrations[client_id] + 1)
    _Olympus_handler_8991._labels = None
    _Olympus_handler_8991._notlabels = None

    def _Olympus_handler_10485(self, replica_id, process_cli_replica):
        print('inside olympus reconfigure_request')
        self._state.logger.warning('reconfigure_request: received reconfig request FROM replica_id=%s', str(replica_id))
        self._state.logger.info('wedged_request: sending wedged requests to all the replicas')
        self._state.count_of_wedged_statements = 0
        wedge_request_id = 0
        self.send(('wedged_request', wedge_request_id), to=self._state.replica_set.values())
        time.sleep(1)
        super()._label('_st_label_10535', block=False)
        _st_label_10535 = 0
        while (_st_label_10535 == 0):
            _st_label_10535 += 1
            if (self._state.count_of_wedged_statements > self._state.T):
                _st_label_10535 += 1
            else:
                super()._label('_st_label_10535', block=True)
                _st_label_10535 -= 1
        self.find_quorum_of_replicas()
    _Olympus_handler_10485._labels = None
    _Olympus_handler_10485._notlabels = None

    def _Olympus_handler_10846(self, replica_id, running_state, client):
        self._state.current_running_state = running_state
        self._state.has_received_running_state_from_random_replica = 1
    _Olympus_handler_10846._labels = None
    _Olympus_handler_10846._notlabels = None

    def _Olympus_handler_10870(self, replica_id, caughtup_message, client):
        self._state.count_of_caughtup_messages = (self._state.count_of_caughtup_messages + 1)
        self._state.caughtup_messages_of_replicas[replica_id] = caughtup_message
    _Olympus_handler_10870._labels = None
    _Olympus_handler_10870._notlabels = None

    def _Olympus_handler_10900(self, wedged_statement, replica_id, client):
        self._state.logger.info("received: 'wedged_statement_from_replica' FROM replica_id=%s", str(replica_id))
        self._state.count_of_wedged_statements = (self._state.count_of_wedged_statements + 1)
        self._state.wedged_statements[replica_id] = wedged_statement
    _Olympus_handler_10900._labels = None
    _Olympus_handler_10900._notlabels = None

    def _Olympus_handler_10938(self, client_id, client):
        self._state.logger.info("received: 'get_current_active_configuration_from_olympus' FROM client_id=%s", str(client))
        self.send(('received_active_configuration_at_client', self._state.replica_set, self._state.public_keys), to=client)
        self._state.logger.info("sent: 'received_active_configuration_at_client' TO client_id=%s", str(client))
    _Olympus_handler_10938._labels = None
    _Olympus_handler_10938._notlabels = None

class Client(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ClientReceivedEvent_6 = []
        self._ClientReceivedEvent_7 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_0', PatternExpr_11440, sources=[PatternExpr_11448], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_11439]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_1', PatternExpr_11533, sources=[PatternExpr_11539], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_11532]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_2', PatternExpr_11563, sources=[PatternExpr_11570], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_11562]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_3', PatternExpr_11682, sources=[PatternExpr_11689], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_11681]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_4', PatternExpr_11917, sources=[PatternExpr_11930], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_11916]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_5', PatternExpr_12052, sources=[PatternExpr_12059], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_12051]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_6', PatternExpr_12125, sources=[PatternExpr_12131], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_7', PatternExpr_12474, sources=[PatternExpr_12479], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, client_id, olympus, T, config_file, **rest_13732):
        super().setup(client_id=client_id, olympus=olympus, T=T, config_file=config_file, **rest_13732)
        self._state.client_id = client_id
        self._state.olympus = olympus
        self._state.T = T
        self._state.config_file = config_file
        self._state.config_file_name = self._state.config_file
        self._state.parent_process = None
        self._state.olympus = self._state.olympus
        self._state.client_id = self._state.client_id
        self._state.request_id = 0
        self._state.private_key = None
        self._state.public_key = None
        self._state.head_replica = None
        self._state.tail_replica = None
        self._state.T = self._state.T
        self._state.replica_set = {}
        self.generate_crypto_keys()
        self._state.client_timeout = 0
        self._state.replica_public_keys = {}
        self._state.global_seq_id = 0
        self._state.result_from_parent_process = None
        self._state.retransmit_id = 0
        self._state.hash_result_from_parent_process = None
        self._state.logger = logging.getLogger(('Client ' + str(self._state.client_id)))
        self._state.logger.setLevel(logging.INFO)
        self._state.handler = logging.FileHandler((str(timestamp) + '_client.log'))
        self._state.handler.setLevel(logging.INFO)
        self._state.formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        self._state.handler.setFormatter(self._state.formatter)
        self._state.logger.addHandler(self._state.handler)
        self._state.switch = 0
        self._state.retransmit_switch = 0
        self._state.parent_request_switch = 0
        self._state.parent_switch = 0
        self._state.verified_result = {}
        self._state.received_active_config_at_client = 0
        self._state.operations = None
        self._state.operation_count = 0
        self._state.operation_iter = None
        self._state.temp_count = 0
        self._state.last_executed_operation = None
        self._state.last_operation_status = 'DONE'

    def run(self):
        self.register_client_and_get_active_configuration_from_olympus()
        self._state.operations = self.getWorkLoad()
        self._state.operation_count = len(self._state.operations)
        self._state.operation_iter = self.get_operation()
        current_time = time.time()
        super()._label('_st_label_12434', block=False)
        _st_label_12434 = 0
        while (_st_label_12434 == 0):
            _st_label_12434 += 1
            if (self._state.received_active_config_at_client == 1):
                _st_label_12434 += 1
            else:
                super()._label('_st_label_12434', block=True)
                _st_label_12434 -= 1
        self._state.logger.info(('Performing operations WITH replicas ' + str(self._state.replica_set)))
        self._state.logger.info(('head_replica is  replicas ' + str(self._state.head_replica)))
        self._state.logger.info(('tail_replica is  replicas ' + str(self._state.tail_replica)))
        self.handle_operation()
        super()._label('_st_label_12471', block=False)

        def ExistentialOpExpr_12472():
            for (_, (_, _, _ConstantPattern12488_), (_ConstantPattern12491_,)) in self._ClientReceivedEvent_7:
                if (_ConstantPattern12488_ == self._id):
                    if (_ConstantPattern12491_ == 'done'):
                        if True:
                            return True
            return False
        _st_label_12471 = 0
        while (_st_label_12471 == 0):
            _st_label_12471 += 1
            if ExistentialOpExpr_12472():
                _st_label_12471 += 1
            else:
                super()._label('_st_label_12471', block=True)
                _st_label_12471 -= 1

    def generate_crypto_keys(self):
        key = nacl.utils.random(nacl.secret.SecretBox.KEY_SIZE)
        naclObject = nacl.signing.SigningKey(key)
        self._state.private_key = naclObject.generate()
        self._state.public_key = self._state.private_key.verify_key

    def is_verified_result(self, client_id, request_id):
        self._state.logger.info('is_verified_result: client_id:%s,request_id:%s ', str(client_id), str(request_id))
        cache_key = ((('00000' + str(client_id)) + '11111') + str(request_id))
        if (cache_key in self._state.verified_result):
            return True
        else:
            return False

    def get_unsigned_hash(self, process_public_key, signed_message):
        try:
            new_digest = process_public_key.verify(signed_message)
            return new_digest
        except:
            self._state.logger.error('nacl.exceptions.BadSignatureError: Signature was forged or corrupt.')
        return False

    def compare_hashes(self, hash1, hash2):
        if sodium_memcmp(hash1, hash2):
            return True
        else:
            return False

    def get_hashed_message(self, msg):
        HASHER = nacl.hash.sha256
        msg_in_bytes = str(msg).encode('utf-8')
        dgst = HASHER(msg_in_bytes, encoder=nacl.encoding.HexEncoder)
        return dgst

    def decode_hash_and_verify(self, hash_digest, signed_message, process_public_key):
        try:
            new_digest = process_public_key.verify(signed_message)
            if sodium_memcmp(hash_digest, new_digest):
                return True
            else:
                return False
        except:
            self._state.logger.error('nacl.exceptions.BadSignatureError: Signature was forged or corrupt.')
        return False

    def get_count_valid_result_proofs(self, result_shuttle):
        self._state.logger.info("inside 'get_count_valid_result_proofs'")
        count = 0
        replica_ids = result_shuttle.get_replica_ids_from_shuttle()
        for replica_id in replica_ids:
            replica_public_key = self._state.replica_public_keys[replica_id]
            replica_result_proof = result_shuttle.get_result_proof_of_replica(replica_id)
            replica_result_signed_value = replica_result_proof.get_result_signed_value_from_result_proof()
            replica_result_hashed_value = replica_result_proof.get_result_hashed_value_from_result_proof()
            result_hashed_value = self.get_unsigned_hash(replica_public_key, replica_result_signed_value)
            if (self.decode_hash_and_verify(replica_result_hashed_value, replica_result_signed_value, replica_public_key) and self.compare_hashes(replica_result_hashed_value, self._state.hash_result_from_parent_process)):
                count += 1
        return count

    def process_result_shuttle(self, result, response_request_id, result_shuttle):
        cache_key = ((('00000' + str(self._state.client_id)) + '11111') + str(response_request_id))
        self._state.verified_result[cache_key] = True
        self._state.logger.info('processing the result and result_shuttle at client_id:%s,for request_id:%s ', str(self._state.client_id), str(response_request_id))
        self.send(('get_result_from_parent_process', self._state.global_seq_id), to=self._state.parent_process)
        self._state.parent_switch = 1
        super()._label('_st_label_11835', block=False)
        _st_label_11835 = 0
        while (_st_label_11835 == 0):
            _st_label_11835 += 1
            if (self._state.parent_switch == 2):
                _st_label_11835 += 1
            else:
                super()._label('_st_label_11835', block=True)
                _st_label_11835 -= 1
        count = self.get_count_valid_result_proofs(result_shuttle)
        self._state.logger.info("seq=%s, result_from_parent_process='%s', result='%s; ,result_proof_match_count=%s,actual_count=%s", str(self._state.global_seq_id), str(self._state.result_from_parent_process), str(result), str(count), str(((2 * self._state.T) + 1)))
        if (count < (self._state.T + 1)):
            self._state.logger.error('need to call reconfig provable case of misbehaviour detected for client_id:%s,request_id:%s result proofs are invalid', str(self._state.client_id), str(response_request_id))
            return False
        else:
            self._state.last_operation_status = 'DONE'
            self._state.logger.info('verified result for client_id:%s,request_id:%s ', str(self._state.client_id), str(response_request_id))
            return True

    def get_active_configuration_from_olympus(self):
        self._state.logger.info(' get_active_configuration_from_olympus: ')
        self._state.received_active_config_at_client = 0
        self.send(('get_current_active_configuration_from_olympus', self._state.client_id), to=self._state.olympus)
        self._state.logger.info("sent: 'get_current_active_configuration_from_olympus' TO Olympus")

    def register_client_and_get_active_configuration_from_olympus(self):
        self._state.logger.info(' register_client_and_get_active_configuration_from_olympus: ')
        self.send(('register_client_at_olympus', self._state.public_key, self._state.client_id), to=self._state.olympus)
        self._state.logger.info("sent: 'register_client_at_olympus' WITH client_id=%s TO Olympus", str(self._state.client_id))
        super()._label('_st_label_12122', block=False)
        olympus = None

        def ExistentialOpExpr_12123():
            nonlocal olympus
            for (_, (_, _, self._state.olympus), (_ConstantPattern12141_, _)) in self._ClientReceivedEvent_6:
                if (_ConstantPattern12141_ == 'client_registered_at_olympus'):
                    if True:
                        return True
            return False
        _st_label_12122 = 0
        while (_st_label_12122 == 0):
            _st_label_12122 += 1
            if ExistentialOpExpr_12123():
                _st_label_12122 += 1
            else:
                super()._label('_st_label_12122', block=True)
                _st_label_12122 -= 1
        self._state.logger.info('client_id=%s registered at Olympus', str(self._state.client_id))
        self.get_active_configuration_from_olympus()

    def get_operation(self):
        for operation in self._state.operations:
            (yield operation)

    def handle_operation(self):
        if (self._state.temp_count >= self._state.operation_count):
            return
        if (self._state.last_operation_status == 'DONE'):
            operation = next(self._state.operation_iter)
        else:
            operation = self._state.last_executed_operation
        self._state.last_operation_status = 'PENDING'
        self._state.last_executed_operation = operation
        self.send(('parent_perform_operation', self._state.client_id, self._state.request_id, operation), to=self._state.parent_process)
        self._state.parent_request_switch = 1
        super()._label('_st_label_12222', block=False)
        _st_label_12222 = 0
        while (_st_label_12222 == 0):
            _st_label_12222 += 1
            if (self._state.parent_request_switch == 2):
                _st_label_12222 += 1
            else:
                super()._label('_st_label_12222', block=True)
                _st_label_12222 -= 1
        self._state.switch = 1
        self._state.retransmit_switch = 1
        client_request = ClientRequest(self._state.client_id, self._state.request_id, self._state.retransmit_id, operation, self._state.private_key, self._id)
        self._state.logger.info("sent: 'perform_operation' WITH client_id=%s, request_id=%s,operation=%s TO head_replica", str(self._state.client_id), str(self._state.request_id), str(operation))
        self.send(('perform_operation', client_request, None, None, None), to=self._state.head_replica)
        self._state.logger.info("sent: 'parent_verify' to parent_process")
        super()._label('_st_label_12280', block=False)
        _st_label_12280 = 0
        self._timer_start()
        while (_st_label_12280 == 0):
            _st_label_12280 += 1
            if (self._state.switch == 2):
                self._state.logger.info('[{handle_operation:operation:%s}] completed done by the client:%s', str(operation), str(self._state.client_id))
                if (self._state.temp_count < self._state.operation_count):
                    self.handle_operation()
                _st_label_12280 += 1
            elif self._timer_expired:
                self._state.logger.info('TIMEOUT occurred, retransmitting request to all replicas')
                self._state.logger.warning('TIMEOUT occurred, retransmitting request to all replicas')
                self._state.retransmit_id = (self._state.retransmit_id + 1)
                client_request.set_retransmitted_id(self._state.retransmit_id)
                self.send(('initiating_retransmit_request', client_request), to=self._state.replica_set.values())
                self._state.logger.info("sent: 'initiating_retransmit_request' WITH client_id=%s, request_id=%s operation=%s TO all replicas", str(self._state.client_id), str(self._state.request_id), str(operation))
                self._state.retransmit_switch = 1
                super()._label('_st_label_12365', block=False)
                _st_label_12365 = 0
                self._timer_start()
                while (_st_label_12365 == 0):
                    _st_label_12365 += 1
                    if (self._state.retransmit_switch == 2):
                        self._state.logger.info('operation:%s completed done by the client:%s before timeout', str(operation), str(self._state.client_id))
                        _st_label_12365 += 1
                    elif self._timer_expired:
                        self._state.logger.error('retransmitted_request:provable case of misbehaviour client_id:%s has not received response for request_id:%s,retransmit_id:%s', str(self._state.client_id), str(self._state.request_id), str(self._state.retransmit_id))
                        self._state.logger.info('failed failed failed')
                        _st_label_12365 += 1
                    else:
                        super()._label('_st_label_12365', block=True, timeout=self._state.client_timeout)
                        _st_label_12365 -= 1
                _st_label_12280 += 1
            else:
                super()._label('_st_label_12280', block=True, timeout=self._state.client_timeout)
                _st_label_12280 -= 1

    def pseudorandom_workload_gen(self, seed, count):
        self._state.logger.info('generating pseudorandom workload for client_id:%s WITH seed:%s and count:%s ', str(self._state.client_id), str(seed), str(count))
        random.seed(seed)
        list_operations = ["put('sports','foot')", "append('sport',' ball')", "get('sports')", "put('player','lionel messi)", "slice('player','0:4')", "get('player')"]
        list_random_operations = []
        for i in range(count):
            list_random_operations.append(list_operations[random.randint(0, (len(list_operations) - 1))])
        return '; '.join(list_random_operations)

    def getWorkLoad(self):
        config = {}
        with open(self._state.config_file_name, 'r') as f:
            for line in f:
                if (not (line[0] == '#')):
                    (key, sep, val) = line.partition('=')
                    if (not (len(sep) == 0)):
                        val = val.strip()
                        config[key.strip()] = (int(val) if str.isdecimal(val) else val)
        workload = config.get((('workload[' + str(self._state.client_id)) + ']'))
        if (workload is None):
            return {}
        self._state.client_timeout = config.get('client_timeout')
        self._state.client_timeout = int(self._state.client_timeout)
        self._state.client_timeout = (self._state.client_timeout / 1000)
        self._state.logger.info('workload=%s', str(workload))
        if ('pseudorandom' in workload):
            open_brace_index = workload.find('(')
            comma_index = workload.find(',')
            close_brace_index = workload.find(')')
            seed = int(workload[(open_brace_index + 1):comma_index].strip())
            count = int(workload[(comma_index + 1):close_brace_index].strip())
            workload = self.pseudorandom_workload_gen(seed, count)
        workload = workload.split(';')
        self._state.operations = []
        for i in range(0, len(workload)):
            item = workload[i].strip()
            operation_dict = {}
            if ('put' in item):
                first_occur = item.find("'")
                second_occur = item.find("'", (first_occur + 1))
                key = item[(first_occur + 1):second_occur]
                first_occur = item.find("'", (second_occur + 1))
                second_occur = item.find("'", (first_occur + 1))
                value = item[(first_occur + 1):second_occur]
                operation_dict['operation'] = 'put'
                operation_dict['key'] = key
                operation_dict['value'] = value
            elif ('append' in item):
                first_occur = item.find("'")
                second_occur = item.find("'", (first_occur + 1))
                key = item[(first_occur + 1):second_occur]
                first_occur = item.find("'", (second_occur + 1))
                second_occur = item.find("'", (first_occur + 1))
                value = item[(first_occur + 1):second_occur]
                operation_dict['operation'] = 'append'
                operation_dict['key'] = key
                operation_dict['value'] = value
            elif ('slice' in item):
                first_occur = item.find("'")
                second_occur = item.find("'", (first_occur + 1))
                key = item[(first_occur + 1):second_occur]
                first_occur = item.find("'", (second_occur + 1))
                second_occur = item.find("'", (first_occur + 1))
                value = item[(first_occur + 1):second_occur]
                operation_dict['operation'] = 'slice'
                operation_dict['key'] = key
                slice_indices = value.split(':')
                operation_dict['value1'] = slice_indices[0]
                operation_dict['value2'] = slice_indices[1]
            elif ('get' in item):
                first_occur = item.find("'")
                second_occur = item.find("'", (first_occur + 1))
                key = item[(first_occur + 1):second_occur]
                operation_dict['operation'] = 'get'
                operation_dict['key'] = key
            self._state.operations.append(operation_dict)
        return self._state.operations

    def _Client_handler_11439(self, replica_set, public_keys, olympus):
        self._state.logger.info("received: 'received_active_configuration_at_client' FROM Olympus")
        count = 0
        for replica_id in range(0, len(replica_set)):
            replica = replica_set[replica_id]
            self._state.replica_set[replica_id] = replica
            if (count == 0):
                self._state.head_replica = replica
            elif (count == (len(replica_set) - 1)):
                self._state.tail_replica = replica
            count = (count + 1)
        for replica_id in public_keys:
            replica_public_key = public_keys[replica_id]
            self._state.replica_public_keys[replica_id] = replica_public_key
        self._state.received_active_config_at_client = 1
    _Client_handler_11439._labels = None
    _Client_handler_11439._notlabels = None

    def _Client_handler_11532(self, parent_process, olympus):
        self._state.logger.info("received: 'client_registered_at_olympus' FROM Olympus")
        self._state.logger.info('client_id=%s is successfully registered', str(self._state.client_id))
        self._state.parent_process = parent_process
    _Client_handler_11532._labels = None
    _Client_handler_11532._notlabels = None

    def _Client_handler_11562(self, result_shuttle, olympus):
        self._state.logger.info("received: 'last_served_request' shuttle FROM Olympus WITH result:%s and last_served_request_id:%s ,actual_id:%s", str(result_shuttle.get_result()), str(self._state.request_id), str(result_shuttle.get_request_id()))
        if ((not (result_shuttle.get_result() is None)) and (result_shuttle.get_request_id() == self._state.request_id)):
            response_request_id = result_shuttle.get_request_id()
            result = result_shuttle.get_result()
            self.process_result_shuttle(result, response_request_id, result_shuttle)
            self.get_active_configuration_from_olympus()
            super()._label('_st_label_11629', block=False)
            _st_label_11629 = 0
            while (_st_label_11629 == 0):
                _st_label_11629 += 1
                if (self._state.received_active_config_at_client == 1):
                    _st_label_11629 += 1
                else:
                    super()._label('_st_label_11629', block=True)
                    _st_label_11629 -= 1
            self._state.logger.info('last_served_request:done received_active_config_at_client after reconfiguration')
            self._state.request_id = (self._state.request_id + 1)
            self._state.temp_count = (self._state.temp_count + 1)
            self.handle_operation()
        else:
            self.get_active_configuration_from_olympus()
            super()._label('_st_label_11665', block=False)
            _st_label_11665 = 0
            while (_st_label_11665 == 0):
                _st_label_11665 += 1
                if (self._state.received_active_config_at_client == 1):
                    _st_label_11665 += 1
                else:
                    super()._label('_st_label_11665', block=True)
                    _st_label_11665 -= 1
            self._state.logger.info('last_served_request:done received_active_config_at_client after reconfiguration')
            self.handle_operation()
    _Client_handler_11562._labels = None
    _Client_handler_11562._notlabels = None

    def _Client_handler_11681(self, result_parent, parent_process):
        self._state.logger.info("received: 'parent_sent_result'")
        self._state.result_from_parent_process = result_parent
        self._state.hash_result_from_parent_process = self.get_hashed_message(result_parent)
        self._state.parent_switch = 2
    _Client_handler_11681._labels = None
    _Client_handler_11681._notlabels = None

    def _Client_handler_11916(self, result_shuttle, result, replica_id, response_request_id, tail_replica):
        self._state.logger.info("received: 'result_shuttle' FROM replica:%s for request_id:%s WITH result=%s", str(replica_id), str(response_request_id), str(result))
        if (self.is_verified_result(self._state.client_id, response_request_id) is False):
            self._state.logger.info("validating 'result_shuttle' FROM replica:%s for request_id:%s WITH result=%s", str(replica_id), str(response_request_id), str(result))
            valid_response = self.process_result_shuttle(result, response_request_id, result_shuttle)
            if (valid_response is True):
                self._state.switch = 2
                self._state.retransmit_switch = 2
                self._state.request_id = (self._state.request_id + 1)
                self._state.temp_count = (self._state.temp_count + 1)
                self._state.logger.info(((((("verified_the_result '" + str(result)) + "' at client_id ") + str(self._state.client_id)) + ' request_id is ') + str((self._state.request_id - 1))))
                self._state.logger.info('sending next op')
        else:
            self._state.logger.info("result_shuttle:already processed 'result_shuttle' FROM replica:%s for request_id:%s WITH result=%s", str(replica_id), str(response_request_id), str(result))
    _Client_handler_11916._labels = None
    _Client_handler_11916._notlabels = None

    def _Client_handler_12051(self, globalseqid, parent_process):
        self._state.logger.info("received: 'parent_performed_operation' FROM parent_process")
        self._state.global_seq_id = globalseqid
        self._state.parent_request_switch = 2
    _Client_handler_12051._labels = None
    _Client_handler_12051._notlabels = None

def get_config_info(config_file_name):
    config = {}
    with open(config_file_name, 'r') as f:
        for line in f:
            if (not (line[0] == '#')):
                (key, sep, val) = line.partition('=')
                if (not (len(sep) == 0)):
                    val = val.strip()
                    config[key.strip()] = (int(val) if str.isdecimal(val) else val)
    return config

class ParentProcess(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ParentProcessReceivedEvent_2 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ParentProcessReceivedEvent_0', PatternExpr_13376, sources=[PatternExpr_13383], destinations=None, timestamps=None, record_history=None, handlers=[self._ParentProcess_handler_13375]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ParentProcessReceivedEvent_1', PatternExpr_13439, sources=[PatternExpr_13450], destinations=None, timestamps=None, record_history=None, handlers=[self._ParentProcess_handler_13438]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ParentProcessReceivedEvent_2', PatternExpr_13715, sources=[PatternExpr_13719], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, total_replica_count, **rest_13732):
        super().setup(total_replica_count=total_replica_count, **rest_13732)
        self._state.total_replica_count = total_replica_count
        self._state.operations_result_list = []
        self._state.logger = logging.getLogger('ParentProcess ')
        self._state.logger.setLevel(logging.INFO)
        self._state.handler = logging.FileHandler((str(timestamp) + '_ParentProcess.log'))
        self._state.handler.setLevel(logging.INFO)
        self._state.formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        self._state.handler.setFormatter(self._state.formatter)
        self._state.logger.addHandler(self._state.handler)
        self._state.data_object = {}
        self._state.global_result_of_operations = {}
        self._state.global_seq_id = 0
        self._state.client_request_map = {}
        self._state.request_issued_by = {}

    def run(self):
        super()._label('_st_label_13712', block=False)
        _st_label_13712 = 0
        while (_st_label_13712 == 0):
            _st_label_13712 += 1
            if PatternExpr_13722.match_iter(self._ParentProcessReceivedEvent_2, SELF_ID=self._id):
                _st_label_13712 += 1
            else:
                super()._label('_st_label_13712', block=True)
                _st_label_13712 -= 1

    def process_operation(self, operation):
        self._state.logger.info('ParentProcess is performing the operation=%s ', str(operation))
        opcode = operation['operation']
        if (opcode == 'put'):
            key = operation['key']
            value = operation['value']
            self._state.data_object[key] = value
            return 'Success'
        elif (opcode == 'get'):
            key = operation['key']
            if (not (key in self._state.data_object)):
                return 'Error'
            value = self._state.data_object[key]
            return value
        elif (opcode == 'slice'):
            key = operation['key']
            if (not (key in self._state.data_object)):
                return 'Error'
            index1 = int(operation['value1'])
            index2 = int(operation['value2'])
            value = self._state.data_object[key]
            value = value[index1:index2]
            self._state.data_object[key] = value
            return value
        elif (opcode == 'append'):
            key = operation['key']
            if (not (key in self._state.data_object)):
                return 'Error'
            value = operation['value']
            value = (self._state.data_object[key] + value)
            self._state.data_object[key] = value
            return 'Success'

    def _ParentProcess_handler_13375(self, globalseqid, client):
        self._state.logger.info("received: 'get_result_from_parent_process' FROM client, global_sequence_id=%s", str(globalseqid))
        result = self._state.global_result_of_operations[str(globalseqid)]
        self._state.logger.info(((('presult=' + str(result)) + ' client_id:') + str(self._state.request_issued_by[str(globalseqid)])))
        self.send(('parent_sent_result', result), to=client)
        self._state.logger.info("sent: 'parent_sent_result' TO client, with result=%s", str(result))
    _ParentProcess_handler_13375._labels = None
    _ParentProcess_handler_13375._notlabels = None

    def _ParentProcess_handler_13438(self, client_id, request_id, operation, client):
        cache_key = ((('00000' + str(client_id)) + '11111') + str(request_id))
        if (not (cache_key in self._state.client_request_map)):
            self._state.logger.info("received: 'parent_perform_operation' FROM client=%s, operation=%s", str(client_id), str(operation))
            result = self.process_operation(operation)
            self._state.global_result_of_operations[str(self._state.global_seq_id)] = result
            self._state.request_issued_by[str(self._state.global_seq_id)] = client_id
            self._state.client_request_map[cache_key] = self._state.global_seq_id
            self._state.global_seq_id += 1
            self.send(('parent_performed_operation', (self._state.global_seq_id - 1)), to=client)
            self._state.logger.info("sent: 'parent_performed_operation to client_id:%s', operation=%s, result=%s", str(client_id), str(operation), str(result))
        else:
            self._state.logger.info("received: duplicate 'parent_perform_operation' FROM client=%s, operation=%s with same request_id=%s", str(client_id), str(operation), str(request_id))
            self.send(('parent_performed_operation', self._state.client_request_map[cache_key]), to=client)
    _ParentProcess_handler_13438._labels = None
    _ParentProcess_handler_13438._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])
    _config_object = {'channel': 'reliable', 'clock': 'Lamport', 'handling': 'all'}

    def run(self):
        config_file_name = 'testcase_perform900.txt'
        logger = logging.getLogger('Main Module')
        logger.setLevel(logging.INFO)
        handler = logging.FileHandler((str(timestamp) + '_MainModule.log'))
        handler.setLevel(logging.INFO)
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        config = get_config_info(config_file_name)
        T = config.get('t')
        num_client = config.get('num_client')
        total_replica_count = ((2 * T) + 1)
        olympus = self.new(Olympus, num=1)
        self._setup(olympus, (T, total_replica_count, config_file_name))
        logger.info('Starting Olympus')
        self._start(olympus)
        logger.info('Olympus started')
        clients = self.new(Client, num=num_client)
        client_id = 0
        for new_client in clients:
            self._setup(new_client, (client_id, olympus, T, config_file_name))
            client_id = (client_id + 1)
        logger.info('Starting %s Clients', str(len(clients)))
        self._start(clients)
        logger.info('%s Clients started', str(len(clients)))
