# -*- generated by 1.0.9 -*-
import da
PatternExpr_230 = da.pat.TuplePattern([da.pat.ConstantPattern('request'), da.pat.FreePattern('c2'), da.pat.FreePattern('p')])
PatternExpr_255 = da.pat.TuplePattern([da.pat.ConstantPattern('release'), da.pat.BoundPattern('_BoundPattern258_'), da.pat.BoundPattern('_BoundPattern259_')])
PatternExpr_288 = da.pat.TuplePattern([da.pat.ConstantPattern('ack'), da.pat.BoundPattern('_BoundPattern291_'), da.pat.BoundPattern('_BoundPattern292_')])
PatternExpr_332 = da.pat.TuplePattern([da.pat.ConstantPattern('request'), da.pat.FreePattern('c'), da.pat.FreePattern('p')])
PatternExpr_401 = da.pat.TuplePattern([da.pat.ConstantPattern('done'), da.pat.BoundPattern('_BoundPattern404_')])
PatternExpr_407 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('done'), da.pat.BoundPattern('_BoundPattern417_')])])
PatternExpr_262 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('release'), da.pat.BoundPattern('_BoundPattern272_'), da.pat.BoundPattern('_BoundPattern273_')])])
PatternExpr_295 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('ack'), da.pat.BoundPattern('_BoundPattern305_'), da.pat.BoundPattern('_BoundPattern306_')])])
_config_object = {'channel': 'fifo', 'clock': 'Lamport'}
import sys
from time import sleep

class P(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._PReceivedEvent_0 = []
        self._PReceivedEvent_1 = []
        self._PReceivedEvent_2 = []
        self._PReceivedEvent_4 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_0', PatternExpr_230, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_1', PatternExpr_255, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_2', PatternExpr_288, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_3', PatternExpr_332, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_331]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_4', PatternExpr_401, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, s, nrequests, id, **rest_496):
        super().setup(s=s, nrequests=nrequests, id=id, **rest_496)
        self._state.s = s
        self._state.nrequests = nrequests
        self._state.id = id
        print(len(self._state.s))
        pass

    def run(self):

        def task():
            self.output('in cs')
            self.output('releasing cs')
        for i in range(self._state.nrequests):
            self.mutex(task)
        self.send(('done', self._id), to=self._state.s)
        super()._label('_st_label_392', block=False)
        p = None

        def UniversalOpExpr_393():
            nonlocal p
            for p in self._state.s:
                if (not PatternExpr_407.match_iter(self._PReceivedEvent_4, _BoundPattern417_=p, SELF_ID=self._id)):
                    return False
            return True
        _st_label_392 = 0
        while (_st_label_392 == 0):
            _st_label_392 += 1
            if UniversalOpExpr_393():
                _st_label_392 += 1
            else:
                super()._label('_st_label_392', block=True)
                _st_label_392 -= 1
        self.output('terminating')

    def mutex(self, task):
        super()._label('request', block=False)
        c = self.logical_clock()
        self.work()
        self.output(((('clock ' + str(c)) + ' my id is ') + str(self._state.id)))
        self.send(('request', c, self._id), to=self._state.s)
        self.output((((('clock after ' + str(c)) + ' my id is ') + str(self._state.id)) + str(self._id)))
        super()._label('_st_label_226', block=False)
        p = c2 = None

        def UniversalOpExpr_228():
            nonlocal p, c2
            for (_, _, (_ConstantPattern247_, c2, p)) in self._PReceivedEvent_0:
                if (_ConstantPattern247_ == 'request'):
                    if (not (PatternExpr_262.match_iter(self._PReceivedEvent_1, _BoundPattern272_=c2, _BoundPattern273_=p, SELF_ID=self._id) or ((c, self._id) < (c2, p)))):
                        return False
            return True
        p = None

        def UniversalOpExpr_281():
            nonlocal p
            for p in self._state.s:
                if (not PatternExpr_295.match_iter(self._PReceivedEvent_2, _BoundPattern305_=c, _BoundPattern306_=p, SELF_ID=self._id)):
                    return False
            return True
        _st_label_226 = 0
        while (_st_label_226 == 0):
            _st_label_226 += 1
            if (UniversalOpExpr_228() and UniversalOpExpr_281()):
                _st_label_226 += 1
            else:
                super()._label('_st_label_226', block=True)
                _st_label_226 -= 1
        self.output(((('clock final ' + str(c2)) + ' my id is ') + str(self._state.id)))
        super()._label('critical_section', block=False)
        task()
        super()._label('release', block=False)
        self.send(('release', c, self._id), to=self._state.s)

    def _P_handler_331(self, c, p):
        self.output(((((('clock in receive ' + str(c)) + ' sender id is ') + str(self._state.id)) + 'my id is') + str(p)))
        self.send(('ack', c, self._id), to=p)
    _P_handler_331._labels = None
    _P_handler_331._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def run(self):
        nprocs = (int(sys.argv[1]) if (len(sys.argv) > 1) else 3)
        nrequests = (int(sys.argv[2]) if (len(sys.argv) > 2) else 1)
        ps = self.new(P, num=nprocs)
        print(type(ps))
        count = 0
        for p in ps:
            self._setup(p, ((ps - {p}), nrequests, count))
            count = (count + 1)
        self._start(ps)
